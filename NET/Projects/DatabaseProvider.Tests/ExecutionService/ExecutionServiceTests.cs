/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Data;
using System.Linq;
using NUnit.Framework;
using NUnit.Framework.SyntaxHelpers;
using NUnitExtension.OutSystems.Framework;
using OutSystems.HubEdition.Extensibility.Data.ExecutionService;
using OutSystems.RuntimeCommon;
using OutSystems.RuntimeCommon.ObfuscationProperties;
using OutSystems.ServerTests.DatabaseProvider.Framework;


namespace OutSystems.ServerTests.DatabaseProvider.ExecutionService {

    public class TestConfiguration : AgnosticDatabaseProviderTestConfiguration {

        protected override string ConfigurationPathSettingName {
            get {
                return "DatabaseProviderTests.ExecutionServiceFilesPath";
            }
        }
    }

    [DashboardTestFixture(DashboardTest.DashboardTestKind)]
    public class ExecutionServiceTests: DatabaseProviderTest<TestConfiguration> {

        [IterativeTestCase(typeof (TestConfiguration), Description = "Validates that the ParameterPrefix returns a valid prefix by executing a query with a parameter. GetParameterForSQL is used for generating the parameter SQL and ParameterPrefix is used to add the parameter to the command.")]
        [TestDetails(TestIssue = "616967", Feature = "Database Abstraction Layer", CreatedBy = "rls")]
        public void TestParameterPrefix(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            var sqlExecutor = new SQLExecutor(databaseServices);
            string sql = string.Format("SELECT VAL FROM DUMMY WHERE ID = {0}", sqlExecutor.GetParameterName(0, typeof (int)));

            int value = sqlExecutor.ExecuteScalar(sql, 1).RuntimeValue<int>();
            Assert.AreEqual(1, value, "ParameterPrefix didn't work as expected. SQL: " + sql);
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof (TestConfiguration), Description = "Check if basic date types are recognized as date parameters.")]
        public void CheckDateTypes(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            var executionService = databaseServices.ExecutionService;
            DbType[] dateTypes = new DbType[] {DbType.Date, DbType.DateTime, DbType.Time};
            foreach (DbType dateType in dateTypes) {
                Assert.IsTrue(executionService.IsDateType(dateType));
            }
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof (TestConfiguration), Description = "Checks if parameter directions are set correctly")]
        public void CheckParameterDirection(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            var executionService = databaseServices.ExecutionService;
            var transactionService = databaseServices.TransactionService;

            using (var connection = transactionService.CreateConnection()) {
                using (var cmd = executionService.CreateCommand(connection, "")) {
                    var param = executionService.CreateParameter(cmd, "Name", DbType.String, "John");
                    
                    ParameterDirection[] paramDirection = new ParameterDirection[] {ParameterDirection.Input, ParameterDirection.InputOutput, ParameterDirection.Output, ParameterDirection.ReturnValue};

                    foreach (ParameterDirection dir in paramDirection) {
                        executionService.SetParameterDirection(param, dir);
                        
                        Assert.AreEqual(param.Direction, dir);
                    }

                }
            }
        }

        [TestDetails(TestIssue = "568662", Feature = "Database Abstraction Layer")]
        [IterativeTestCase(typeof (TestConfiguration), Description = "Checks if parameter values are set correctly")]
        public void ParameterSetTest(DatabaseProviderTestCase tc) {
            var databaseServices = tc.Services;
            var executionService = databaseServices.ExecutionService;
            var transactionService = databaseServices.TransactionService;

            using (var connection = transactionService.CreateConnection()) {
                using (var cmd = executionService.CreateCommand(connection, "select name from NameTable where name = @name")) {

                    var param = executionService.CreateParameter(cmd, "Name", DbType.Int32, 4);

                    Assert.AreEqual(4, Convert.ToInt32(param.Value));

                    executionService.SetParameterValue(param, DbType.Int32, 4433);

                    Assert.AreEqual(4433, Convert.ToInt32(param.Value));
                }
            }
        }

        [TestDetails(TestIssue = "708477", Feature = "Database Abstraction Layer", CreatedBy = "rls")]
        [IterativeTestCase(typeof (TestConfiguration), Description = "Validates the conversion of decimal values fetched from the database to the native types, using a query that divides 1.0 by 3.0. The query is executed using the ExecuteScalar and ExecuteReader methods and passing the results through the TransformDatabaseToRuntimeValue method.")]
        public void TestDecimalConversionPrecision(DatabaseProviderTestCase tc) {
            var executionService = tc.Services.ExecutionService;
            decimal expected = RoundDecimal(1m/3m);
            using (var conn = tc.Services.TransactionService.CreateConnection()) {
                string sql = string.Format("SELECT 1.0/3.0 as Val FROM DUMMY");
                // Test ExecuteScalar
                using (IDbCommand cmd = executionService.CreateCommand(conn, sql)) {
                    try {
                        decimal obtained = RoundDecimal(Convert.ToDecimal(executionService.TransformDatabaseToRuntimeValue(executionService.ExecuteScalar(cmd))));
                        Assert.AreEqual(expected, obtained, "'" + sql + "' didn't return the expected value");
                    }  catch (Exception e) {
                        throw new Exception("Error occured when executing 'ExecuteScalar() from command '" + sql + "': " +
                                            e.Message);
                    }
                }
                // Test ExecuteReader
                using (IDbCommand cmd = executionService.CreateCommand(conn, sql)) {
                    try {
                        using (var reader = executionService.ExecuteReader(cmd)) {
                            if (!reader.Read()) {
                                throw new Exception("Reader didn't return a value from the database");
                            }
                            decimal obtained = RoundDecimal(Convert.ToDecimal(executionService.TransformDatabaseToRuntimeValue(reader[0])));
                            decimal obtained2 = RoundDecimal(Convert.ToDecimal(executionService.TransformDatabaseToRuntimeValue(reader["Val"])));
                            decimal obtained3 = RoundDecimal(Convert.ToDecimal(executionService.TransformDatabaseToRuntimeValue(reader.GetDecimal(0))));
                            Assert.AreEqual(expected, obtained, "'" + sql + "' didn't return the expected value");
                            Assert.AreEqual(obtained, obtained2, "IDataReader[i] didn't return the same as IDataReader[string]");
                            Assert.AreEqual(obtained, obtained3, "IDataReader[i] didn't return the same as IDataReader.GetDecimal(i)");
                        }
                    }  catch (Exception e) {
                        throw new Exception("Error occured when executing 'ExecuteReader() from command '" + sql + "': " +
                                            e.Message);
                    }
                }
            }
        }


        [TestDetails(TestIssue = "729792", Feature = "Database Abstraction Layer", CreatedBy = "rfe")]
        [IterativeTestCase(typeof (TestConfiguration),
            Description = "Validates if we can set more than one parameter with big (>4K chars) and small strings.")]
        public void TestSetBigParameterStringValues(DatabaseProviderTestCase tc) {
            IExecutionService executionService = tc.Services.ExecutionService;

            string sql = String.Format(
                "INSERT INTO {0} (ID, VAL_SMALL1, VAL_SMALL2, VAL_BIG1, VAL_BIG2) VALUES (1, {1}val1, {1}val2, {1}val3, {1}val4)",
                tc.Services.DMLService.Identifiers.EscapeIdentifier("BIG_DATA"), executionService.ParameterPrefix);

            const string verySmallStr = "a";
            string smallStr = NSizedString(50), mediumStr = NSizedString(4000), bigStr = NSizedString(20000);

            var paramValuesInTests = new string[][] {
                new string[] {verySmallStr, verySmallStr, verySmallStr, verySmallStr}, // First test will very small strings
                new string[] {smallStr, smallStr, mediumStr, mediumStr}, // Small and medium strings
                new string[] {smallStr, smallStr, bigStr, bigStr}, // Small and big strings
            };

            using (var conn = tc.Services.TransactionService.CreateConnection()) {
                foreach (string[] paramValues in paramValuesInTests) {
                    using (IDbCommand cmd = executionService.CreateCommand(conn, sql)) {
                        for (int i = 1; i <= 4; i++) {
                            executionService.CreateParameter(cmd, "val" + i, DbType.AnsiString, paramValues[i - 1]);
                        }

                        Assert.AreEqual(1, executionService.ExecuteNonQuery(cmd));
                    }
                }
            }
        }

        private static decimal RoundDecimal(decimal value) {
            return Math.Round(value, 3);
        }

        private static string NSizedString(int n) {
            IEnumerable<char> chars = Enumerable.Repeat('a', n);

            char[] arrayChars = 
                 
                chars.ToArray();

            return new String(arrayChars);
        }
    }
}
