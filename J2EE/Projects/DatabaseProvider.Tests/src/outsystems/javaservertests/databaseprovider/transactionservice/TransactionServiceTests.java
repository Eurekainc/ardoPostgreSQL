/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.javaservertests.databaseprovider.transactionservice;

import java.sql.*;
import java.text.*;
import java.util.*;
import org.junit.*;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.*;
import outsystems.hubedition.extensibility.data.transactionservice.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.servertests.databaseprovider.framework.*;
import java.math.BigDecimal;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOTransaction;
import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.hubedition.extensibility.data.transactionservice.InvalidCommitOrRollbackTransactionException;
import outsystems.hubedition.extensibility.data.transactionservice.InvalidTransactionReleaseException;
import outsystems.hubedition.extensibility.data.transactionservice.ITransactionManager;
import outsystems.hubedition.extensibility.data.transactionservice.ITransactionService;
import outsystems.junit.framework.DashboardTestFixture;
import outsystems.junit.framework.IterativeTestCase;
import outsystems.junit.framework.JUnitTestAdapter;
import outsystems.junit.framework.TestDetails;
import outsystems.servertests.databaseprovider.framework.DashboardTest;
import outsystems.servertests.databaseprovider.framework.DatabaseProviderTest;
import outsystems.servertests.databaseprovider.framework.DatabaseProviderTestCase;
import outsystems.testscommon.AssertUtils;


@org.junit.runner.RunWith(outsystems.junit.logic.DashboardTestRunner.class)
@DashboardTestFixture(testKind=DashboardTest.DashboardTestKind)
public class TransactionServiceTests extends DatabaseProviderTest<TestConfiguration> {
    public static final TypeInformation<TransactionServiceTests> TypeInfo = TypeInformation.get(TransactionServiceTests.class);
    
    private final void withTransactionManager(ITransactionManager tm, Action.Action1_Lambda<ITransactionManager> action) {
        try {
            action.execute(tm);
        } finally{
            try {
                tm.freeupResources(false);
            }catch (Exception exceptionToHandle) {
            
        }
    }
    
}

private final void expectException(Class<?> exceptionType, Action.Action0_Lambda body) {
    
    Class<?> gotException = null;
    try {
        body.execute();
    }catch (Exception exceptionToHandle) {
        exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
        
        {
            Exception e = (Exception)exceptionToHandle;
            gotException = e.getClass();
        }
    }
    
    Assert.assertNotNull("Should have thrown " + exceptionType.getSimpleName() + " exception", gotException);
    Assert.assertEquals("Should have thrown " + exceptionType.getSimpleName() + " exception", (Object) (exceptionType), (Object) (gotException));
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Getting a ReadOnlyTransaction after releasing it returns the same transaction", TestIssue="568662", Feature="Database Abstraction Layer")
public final void getConsecutiveTransactionsWithRelease(DatabaseProviderTestCase tc) {
    IDatabaseServices services = tc.getServices();
    withTransactionManager(services.getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
        ADOTransaction trans1 = tm.getReadOnlyTransaction();
        tm.releaseTransaction(trans1);
        ADOTransaction trans2 = tm.getReadOnlyTransaction();
        Assert.assertEquals((Object) (trans1), (Object) (trans2));
    });
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Getting a PrivateTransaction after releasing a ReadOnlyTransaction doesn't return the same transaction", TestIssue="568662", Feature="Database Abstraction Layer")
public final void getConsecutiveTransactionsUsingPrivate(DatabaseProviderTestCase tc) {
    IDatabaseServices services = tc.getServices();
    withTransactionManager(services.getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
        ADOTransaction trans1 = tm.getReadOnlyTransaction();
        tm.releaseTransaction(trans1);
        ADOTransaction trans2 = tm.getCommitableTransaction();
        Assert.assertNotEquals("Transactions must be different", (Object) (trans1), (Object) (trans2));
    });
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Consecutively getting the MainTransaction returns the same transaction", TestIssue="568662", Feature="Database Abstraction Layer")
public final void getRequestTransaction(DatabaseProviderTestCase tc) {
    IDatabaseServices services = tc.getServices();
    withTransactionManager(services.getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
        ADOTransaction trans1 = tm.getRequestTransaction();
        ADOTransaction trans2 = tm.getRequestTransaction();
        Assert.assertEquals((Object) (trans1), (Object) (trans2));
    });
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Releasing a Transaction causes an InvalidReleaseException", TestIssue="568662", Feature="Database Abstraction Layer")
public final void privateTransactionNotReleasable(DatabaseProviderTestCase tc) {
    final RefParmHolder<IDatabaseServices> services = new RefParmHolder<IDatabaseServices>(tc.getServices());
    expectException(InvalidTransactionReleaseException.class, () -> {
        withTransactionManager(services.getVal().getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
            ADOTransaction trans = tm.getCommitableTransaction();
            tm.releaseTransaction(trans);
        });
    });
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Commiting a ReadOnly Transaction causes an InvalidCommitOrRollbackException", TestIssue="568662", Feature="Database Abstraction Layer")
public final void readOnlyTransactionNotCommitable(DatabaseProviderTestCase tc) {
    final RefParmHolder<IDatabaseServices> services = new RefParmHolder<IDatabaseServices>(tc.getServices());
    expectException(InvalidCommitOrRollbackTransactionException.class, () -> {
        withTransactionManager(services.getVal().getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
            ADOTransaction trans = tm.getReadOnlyTransaction();
            tm.commitTransaction(trans);
        });
    });
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Commiting a Main Transaction causes an InvalidCommitOrRollbackException", TestIssue="568662", Feature="Database Abstraction Layer")
public final void mainTransactionNotCommitable(DatabaseProviderTestCase tc) {
    final RefParmHolder<IDatabaseServices> services = new RefParmHolder<IDatabaseServices>(tc.getServices());
    expectException(InvalidCommitOrRollbackTransactionException.class, () -> {
        withTransactionManager(services.getVal().getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
            ADOTransaction trans = tm.getRequestTransaction();
            tm.commitTransaction(trans);
        });
    });
}

@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Getting a PrivateTransactions increments busy transaction pool count", TestIssue="568662", Feature="Database Abstraction Layer")
public final void busyPrivateTransactionPoolCount(DatabaseProviderTestCase tc) {
    IDatabaseServices services = tc.getServices();
    withTransactionManager(services.getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
        int initialCount = tm.getBusyTransactionCount();
        ADOTransaction privateTrans1 = tm.getCommitableTransaction();
        Assert.assertTrue(tm.getBusyTransactionCount() == (initialCount + 1));
    });
}


@IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
@TestDetails(Description="Freeing up resources zeroes busy transaction pool count", TestIssue="568662", Feature="Database Abstraction Layer")
public final void freeupResourcesClearsBusyTransactionPool(DatabaseProviderTestCase tc) {
    IDatabaseServices services = tc.getServices();
    withTransactionManager(services.getTransactionService().createTransactionManager(), (ITransactionManager tm) -> {
        ADOTransaction privateTrans1 = tm.getCommitableTransaction();
        ADOTransaction privateTrans2 = tm.getCommitableTransaction();
        tm.freeupResources(false);
        Assert.assertTrue(tm.getBusyTransactionCount() == 0);
    });
}


public TransactionServiceTests() {
    super(TestConfiguration.TypeInfo);
}
}
