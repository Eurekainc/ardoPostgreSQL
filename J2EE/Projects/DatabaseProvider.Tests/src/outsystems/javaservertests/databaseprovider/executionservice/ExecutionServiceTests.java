/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.javaservertests.databaseprovider.executionservice;

import java.sql.*;
import java.text.*;
import java.util.*;
import linqbridge.linq.*;
import org.junit.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.executionservice.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import outsystems.servertests.databaseprovider.framework.*;
import java.math.BigDecimal;
import linqbridge.linq.LinqMethods;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOCommand;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOParameter;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOParameterDirection;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ConnectionUtils;
import outsystems.hubedition.extensibility.data.dmlservice.IDMLIdentifiers;
import outsystems.hubedition.extensibility.data.dmlservice.IDMLService;
import outsystems.hubedition.extensibility.data.executionservice.ExecutionServiceExtensions;
import outsystems.hubedition.extensibility.data.executionservice.IExecutionService;
import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.hubedition.extensibility.data.transactionservice.ITransactionService;
import outsystems.junit.framework.DashboardTestFixture;
import outsystems.junit.framework.IterativeTestCase;
import outsystems.junit.framework.JUnitTestAdapter;
import outsystems.junit.framework.TestDetails;
import outsystems.runtimecommon.CollectionsExtensions;
import outsystems.runtimecommon.StringUtilities;
import outsystems.servertests.databaseprovider.framework.BaseDatabaseProviderTest;
import outsystems.servertests.databaseprovider.framework.DashboardTest;
import outsystems.servertests.databaseprovider.framework.DatabaseProviderTest;
import outsystems.servertests.databaseprovider.framework.DatabaseProviderTestCase;
import outsystems.testscommon.AssertUtils;


@org.junit.runner.RunWith(outsystems.junit.logic.DashboardTestRunner.class)
@DashboardTestFixture(testKind=DashboardTest.DashboardTestKind)
public class ExecutionServiceTests extends DatabaseProviderTest<TestConfiguration> {
    public static final TypeInformation<ExecutionServiceTests> TypeInfo = TypeInformation.get(ExecutionServiceTests.class);
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Validates that the ParameterPrefix returns a valid prefix by executing a query with a parameter. GetParameterForSQL is used for generating the parameter SQL and ParameterPrefix is used to add the parameter to the command.", TestIssue="616967", Feature="Database Abstraction Layer", CreatedBy="rls")
    public final void testParameterPrefix(DatabaseProviderTestCase tc) throws Exception {
        IDatabaseServices databaseServices = tc.getServices();
        SQLExecutor sqlExecutor = new SQLExecutor(databaseServices);
        String sql = StringUtils.format("SELECT VAL FROM DUMMY" + getMachineName() + " WHERE ID = {0}", new Object[] {sqlExecutor.getParameterName(0, int.class)});
        
        int value = sqlExecutor.executeScalar(sql, Integer.valueOf(1)).<Integer>runtimeValue(TypeInformation.Integer).intValue();
        Assert.assertEquals("ParameterPrefix didn't work as expected. SQL: " + sql, (Object) (1), (Object) (value));
    }
    
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Check if basic date types are recognized as date parameters.", TestIssue="568662", Feature="Database Abstraction Layer")
    public final void checkDateTypes(DatabaseProviderTestCase tc) {
        IDatabaseServices databaseServices = tc.getServices();
        IExecutionService executionService = databaseServices.getExecutionService();
        int[] dateTypes = new int[] { Types.TIMESTAMP, Types.TIMESTAMP, Types.TIMESTAMP };
        for (int dateType : dateTypes) {
            Assert.assertTrue(ExecutionServiceExtensions.isDateType(executionService, dateType));
        }
    }
    
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Checks if parameter directions are set correctly", TestIssue="568662", Feature="Database Abstraction Layer")
    public final void checkParameterDirection(DatabaseProviderTestCase tc) throws SQLException {
        IDatabaseServices databaseServices = tc.getServices();
        IExecutionService executionService = databaseServices.getExecutionService();
        ITransactionService transactionService = databaseServices.getTransactionService();
        {
            Connection 
            connection = transactionService.createConnection();
            try 
            {
                {
                    ADOCommand cmd = executionService.createCommand(connection, "");
                    try 
                    {
                        ADOParameter param = executionService.createParameter(cmd, "Name", Types.VARCHAR, "John");
                        int[] paramDirection = new int[] { ADOParameterDirection.Input, ADOParameterDirection.Output};
                        for (int dir : paramDirection) {
                            executionService.setParameterDirection(param, dir);
                            Assert.assertEquals((long) param.getDirection(), (long) Integer.valueOf(dir));}
                        
                    }
                    finally {
                        if (cmd!= null) {
                            cmd.cleanUp();
                        }
                    }
                }
            }
            finally {
                if (connection!= null) {
                    ConnectionUtils.closeConnection(connection);
                }
            }
        }
    }
    
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Checks if parameter values are set correctly", TestIssue="568662", Feature="Database Abstraction Layer")
    public final void parameterSetTest(DatabaseProviderTestCase tc) throws SQLException {
        IDatabaseServices databaseServices = tc.getServices();
        IExecutionService executionService = databaseServices.getExecutionService();
        ITransactionService transactionService = databaseServices.getTransactionService();
        {
            Connection 
            connection = transactionService.createConnection();
            try 
            {
                {
                    ADOCommand cmd = executionService.createCommand(connection, "select name from NameTable" + getMachineName() + " where name = @name");
                    try 
                    {
                        
                        ADOParameter param = executionService.createParameter(cmd, "Name", Types.INTEGER, Integer.valueOf(4));
                        
                        Assert.assertEquals((Object) (4), (Object) (ConvertUtils.toInt(param.getValue())));
                        
                        executionService.setParameterValue(param, Types.INTEGER, Integer.valueOf(4433));
                        
                        Assert.assertEquals((Object) (4433), (Object) (ConvertUtils.toInt(param.getValue())));
                    }
                    finally {
                        if (cmd!= null) {
                            cmd.cleanUp();
                        }
                    }
                }
            }
            finally {
                if (connection!= null) {
                    ConnectionUtils.closeConnection(connection);
                }
            }
        }
    }
    
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Validates the conversion of decimal values fetched from the database to the native types, using a query that divides 1.0 by 3.0. The query is executed using the ExecuteScalar and ExecuteReader methods and passing the results through the TransformDatabaseToRuntimeValue method.", TestIssue="708477", Feature="Database Abstraction Layer", CreatedBy="rls")
    public final void testDecimalConversionPrecision(DatabaseProviderTestCase tc) throws Exception {
        IExecutionService executionService = tc.getServices().getExecutionService();
        BigDecimal expected = roundDecimal(new BigDecimal("1").divide(new BigDecimal("3"), DecimalUtils.SCALE, DecimalUtils.ROUNDING_MODE));
        {
            Connection conn = tc.getServices().getTransactionService().createConnection();
            try 
            {
                String sql = StringUtils.format("SELECT 1.0/3.0 as Val FROM DUMMY" + getMachineName(), new Object[] {});
                {
                    ADOCommand // Test ExecuteScalar
                    cmd = executionService.createCommand(conn, sql);
                    try 
                    {
                        try {
                            BigDecimal obtained = roundDecimal(ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(executionService.executeScalar(cmd))));
                            Assert.assertEquals("'" + sql + "' didn't return the expected value", (Object) (expected), (Object) (obtained));
                        }catch (Throwable exceptionToHandle) {
                            exceptionToHandle = WrappedException.unwrapThrowableIfNeeded(exceptionToHandle);
                            
                            if (exceptionToHandle instanceof ThreadDeath) {
                                throw (ThreadDeath) exceptionToHandle;
                            } else {
                                Throwable e = (Throwable) exceptionToHandle;
                                throw new Exception("Error occurred when executing 'ExecuteScalar() from command '" + sql + "': " + 
                                    ExceptionUtils.getExceptionTypeOrMessage(e));
                            }
                        }
                    }
                    finally {
                        if (cmd!= null) {
                            cmd.cleanUp();
                        }
                    }
                }
                {
                    ADOCommand // Test ExecuteReader
                    cmd = executionService.createCommand(conn, sql);
                    try 
                    {
                        try {
                            {
                                OSResultSet reader = executionService.executeReader(cmd);
                                try 
                                {
                                    if (!reader.next())
                                    {
                                        throw new Exception("Reader didn't return a value from the database");
                                    }
                                    BigDecimal obtained = roundDecimal(ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(reader.getObject(1))));
                                    BigDecimal obtained2 = roundDecimal(ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(reader.getObject("Val"))));
                                    BigDecimal obtained3 = roundDecimal(ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(reader.getBigDecimal(1))));
                                    Assert.assertEquals("'" + sql + "' didn't return the expected value", (Object) (expected), (Object) (obtained));
                                    Assert.assertEquals("IDataReader[i] didn't return the same as IDataReader[string]", (Object) (obtained), (Object) (obtained2));
                                    Assert.assertEquals("IDataReader[i] didn't return the same as IDataReader.GetDecimal(i)", (Object) (obtained), (Object) (obtained3));
                                }
                                finally {
                                    if (reader!= null) {
                                        reader.dispose();
                                    }
                                }
                            }
                        }catch (Throwable exceptionToHandle1) {
                            exceptionToHandle1 = WrappedException.unwrapThrowableIfNeeded(exceptionToHandle1);
                            
                            if (exceptionToHandle1 instanceof ThreadDeath) {
                                throw (ThreadDeath) exceptionToHandle1;
                            } else {
                                Throwable e = (Throwable) exceptionToHandle1;
                                throw new Exception("Error occurred when executing 'ExecuteReader() from command '" + sql + "': " + 
                                    ExceptionUtils.getExceptionTypeOrMessage(e));
                            }
                        }
                    }
                    finally {
                        if (cmd!= null) {
                            cmd.cleanUp();
                        }
                    }
                }
            }
            finally {
                if (conn!= null) {
                    ConnectionUtils.closeConnection(conn);
                }
            }
        }
    }
    
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Validates that there is no conversion problem when reading a decimal from the DB that does not fit the primitive decimal type.", TestIssue="1105735", Feature="Database Abstraction Layer", CreatedBy="ham")
    public final void testDecimalOverPrimitivePrecisionLimit(DatabaseProviderTestCase tc) throws Exception {
        IExecutionService executionService = tc.getServices().getExecutionService();
        
        //The 1st value should be rounded to 29 digits
        //The 2nd value should be rounded to 28 digits
        String[] vals = new String[] { "1000000000000000000000.123456789", "9000000000000000000000.123456789" };
        BigDecimal[] expected = new BigDecimal[] { new BigDecimal("1000000000000000000000.123456789"), new BigDecimal("9000000000000000000000.123456789") };
        {
            Connection 
            conn = tc.getServices().getTransactionService().createConnection();
            try 
            {
                
                for( int i = 0; i < vals.length; i++)
                {
                    String sql = StringUtils.format(StringUtilities.f("SELECT {0} as Val FROM DUMMY", vals[i]) + getMachineName(), new Object[] {});
                    {
                        ADOCommand // Test ExecuteScalar
                        cmd = executionService.createCommand(conn, sql);
                        try 
                        {
                            try {
                                BigDecimal obtained = ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(executionService.executeScalar(cmd)));
                                Assert.assertEquals("'" + sql + "' didn't return the expected value", (Object) (expected[i]), (Object) (obtained));
                            }catch (Throwable exceptionToHandle) {
                                exceptionToHandle = WrappedException.unwrapThrowableIfNeeded(exceptionToHandle);
                                
                                if (exceptionToHandle instanceof ThreadDeath) {
                                    throw (ThreadDeath) exceptionToHandle;
                                } else {
                                    Throwable e = (Throwable) exceptionToHandle;
                                    throw new Exception("Error occured when executing 'ExecuteScalar() from command '" + sql + "': " + 
                                        ExceptionUtils.getExceptionTypeOrMessage(e));
                                }
                            }
                        }
                        finally {
                            if (cmd!= null) {
                                cmd.cleanUp();
                            }
                        }
                    }
                    {
                        ADOCommand // Test ExecuteReader
                        cmd = executionService.createCommand(conn, sql);
                        try 
                        {
                            try {
                                {
                                    OSResultSet reader = executionService.executeReader(cmd);
                                    try 
                                    {
                                        if (!reader.next())
                                        {
                                            throw new Exception("Reader didn't return a value from the database");
                                        }
                                        BigDecimal obtained = ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(reader.getObject(1)));
                                        BigDecimal obtained2 = ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(reader.getObject("Val")));
                                        BigDecimal obtained3 = ConvertUtils.toBigDecimal(executionService.transformDatabaseToRuntimeValue(reader.getBigDecimal(1)));
                                        Assert.assertEquals("'" + sql + "' didn't return the expected value", (Object) (expected[i]), (Object) (obtained));
                                        Assert.assertEquals("IDataReader[i] didn't return the same as IDataReader[string]", (Object) (obtained), (Object) (obtained2));
                                        Assert.assertEquals("IDataReader[i] didn't return the same as IDataReader.GetDecimal(i)", (Object) (obtained), (Object) (obtained3));
                                    }
                                    finally {
                                        if (reader!= null) {
                                            reader.dispose();
                                        }
                                    }
                                }
                            }catch (Throwable exceptionToHandle1) {
                                exceptionToHandle1 = WrappedException.unwrapThrowableIfNeeded(exceptionToHandle1);
                                
                                if (exceptionToHandle1 instanceof ThreadDeath) {
                                    throw (ThreadDeath) exceptionToHandle1;
                                } else {
                                    Throwable e = (Throwable) exceptionToHandle1;
                                    throw new Exception("Error occured when executing 'ExecuteReader() from command '" + sql + "': " + 
                                        ExceptionUtils.getExceptionTypeOrMessage(e));
                                }
                            }
                        }
                        finally {
                            if (cmd!= null) {
                                cmd.cleanUp();
                            }
                        }
                    }
                }
            }
            finally {
                if (conn!= null) {
                    ConnectionUtils.closeConnection(conn);
                }
            }
        }
    }
    
    
    
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Validates if we can set more than one parameter with big (>4K chars) and small strings.", TestIssue="729792", Feature="Database Abstraction Layer", CreatedBy="rfe")
    public final void testSetBigParameterStringValues(DatabaseProviderTestCase tc) throws Exception {
        IDatabaseServices databaseServices = tc.getServices();
        final RefParmHolder<SQLExecutor> sqlExecutor = new RefParmHolder<SQLExecutor>(new SQLExecutor(databaseServices));
        
        String sql = "INSERT INTO " + databaseServices.getDMLService().getIdentifiers().escapeIdentifier("BIG_DATA" + getMachineName()) + " (ID, VAL_SMALL1, VAL_SMALL2, VAL_BIG1, VAL_BIG2) VALUES (1, " + CollectionsExtensions.strCat(LinqMethods.select(LinqMethods.range(0, 4), (Integer i) -> {
    return sqlExecutor.getVal().getParameterName(i, String.class);
}), ", ") + ")";
        
        final String verySmallStr = "a";
        String smallStr = nSizedString(50);
        String mediumStr = nSizedString(4000);
        String bigStr = nSizedString(20000);
        
        String[][] paramValuesInTests = new String[][] { new String[] { verySmallStr, verySmallStr, verySmallStr, verySmallStr }, // First test will very small strings
        new String[] { smallStr, smallStr, mediumStr, mediumStr }, // Small and medium strings
        new String[] { smallStr, smallStr, bigStr, bigStr } };
        // Small and big strings
        
        for(int paramValuesIter=0; paramValuesIter < paramValuesInTests.length; paramValuesIter++)
        {
            Object[] paramValues = (Object[]) paramValuesInTests[paramValuesIter];
            Assert.assertEquals((Object) (1), (Object) (sqlExecutor.getVal().executeNonQuery(sql, paramValues)));
        }
    }
    
    
    private static BigDecimal roundDecimal(BigDecimal value) {
        return value.setScale(3, DecimalUtils.ROUNDING_MODE);
    }
    
    private static String nSizedString(int n) {
        Iterable<Character> chars = LinqMethods.repeat(TypeInformation.Character, 'a', n);
        
        char[] arrayChars = (char[]) ArrayUtils.toNonNullableArray(LinqMethods.toArray(TypeInformation.Character, chars), Character.TYPE, null);
        
        return new String(arrayChars);
    }
    @IterativeTestCase(iteratorType=ServerOnlyTestConfiguration.class)
    @TestDetails(Description="Validates that we can do 2 consecutive selects over a connection, without reading its resultset.", TestIssue="JAVART-234", Feature="Database Abstraction Layer", CreatedBy="lfl")
    public final void testConsecutiveExecutionsNonRead(DatabaseProviderTestCase tc) {
        IDatabaseServices databaseServices = tc.getServices();
        
        try {
            {
                Connection con = databaseServices.getTransactionService().createConnection();
                try 
                {
                    IExecutionService e = databaseServices.getExecutionService();
                    {
                        ADOCommand cmd = e.createCommand(con, "select ID from DUMMY" + getMachineName());
                        try 
                        {
                            cmd.setCommandTimeout( 30 );
                            cmd.execute();
                            cmd.setCommandText( "select ID, VAL from DUMMY" + getMachineName() );
                            cmd.execute();
                        }
                        finally {
                            if (cmd!= null) {
                                cmd.cleanUp();
                            }
                        }
                    }
                }
                finally {
                    if (con!= null) {
                        ConnectionUtils.closeConnection(con);
                    }
                }
            }
        }catch (Exception exceptionToHandle) {
            exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
            
            {
                Exception e = (Exception)exceptionToHandle;
                Assert.fail("Should not crash : " + ExceptionUtils.getExceptionTypeOrMessage(e));
            }
        }
    }
    
    
    @IterativeTestCase(iteratorType=TestConfiguration.class)
    @TestDetails(Description="Tests if we replaced empty strings by 0s when inspecting floats/doubles on the database side.", Feature="Database Abstraction Layer")
    public final void transformRuntimeToDatabaseValueReplacesEmptyStringsWithZeros(DatabaseProviderTestCase tc) {
        IDatabaseServices databaseServices = tc.getServices();
        IExecutionService executionService = databaseServices.getExecutionService();
        
        int[] numericTypes = new int[] { Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.TINYINT, Types.TINYINT };
        
        int[] decimalTypes = new int[] { Types.REAL, Types.DECIMAL, Types.FLOAT, Types.DOUBLE, Types.NUMERIC };
        
        Object value = null;
        
        for (int numType : numericTypes) {
            value = executionService.transformRuntimeToDatabaseValue(numType, "");
            Assert.assertEquals((Object) (0), (Object) (value));
        }
        
        
        for (int decType : decimalTypes) {
            value = executionService.transformRuntimeToDatabaseValue(decType, "");
            Assert.assertEquals((Object) (new BigDecimal(0)), (Object) (value));
        }
    }
    
    public ExecutionServiceTests() {
        super(TestConfiguration.TypeInfo);
    }
}
