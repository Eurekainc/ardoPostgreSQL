/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.servertests.databaseprovider.framework;

import java.io.*;
import java.text.*;
import java.util.*;
import java.util.regex.*;
import linqbridge.linq.*;
import linqbridge.xml.linq.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.configurationservice.*;
import outsystems.hubedition.extensibility.data.configurationservice.metaconfiguration.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import java.math.BigDecimal;
import linqbridge.linq.LinqMethods;
import linqbridge.xml.linq.XDocument;
import outsystems.hubedition.extensibility.data.configurationservice.Deserializer;
import outsystems.hubedition.extensibility.data.configurationservice.Deserializers;
import outsystems.hubedition.extensibility.data.configurationservice.IIntegrationDatabaseConfiguration;
import outsystems.hubedition.extensibility.data.configurationservice.IRuntimeDatabaseConfiguration;
import outsystems.hubedition.extensibility.data.configurationservice.metaconfiguration.IParameter;
import outsystems.hubedition.extensibility.data.configurationservice.metaconfiguration.MetaDatabaseConfiguration;
import outsystems.hubedition.extensibility.data.IProviderProperties;
import outsystems.runtimecommon.DatabaseProviderKey;


public abstract class BaseDatabaseProviderTestConfiguration<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> implements IDatabaseProviderTestConfiguration<TDatabaseProvider>, IGenericObject {
    
    private static class ConfigurationLoader<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> implements IGenericObject {
        private String directoryToSearch;
        private TDatabaseProvider provider;
        
        public ConfigurationLoader(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, TDatabaseProvider provider, String directoryToSearch){
            staticInitConfigurationLoader(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
            instanceInitConfigurationLoader(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
            this.directoryToSearch = directoryToSearch;
            this.provider = provider;
        }
        
        private final String configurationFilePath(String configFileSuffix) {
            File directory = new File(directoryToSearch);
            for (File file : FileUtils.getFiles( directory )) {
                if (file.getName().endsWith(configFileSuffix))
                {
                    return file.getAbsolutePath();
                }
            }
            return null;
        }
        
        private final IRuntimeDatabaseConfiguration loadConfiguration(String filepath) throws ConfigurationSerializationException, IOException, javax.xml.stream.XMLStreamException, UnsupportedOperationException {
            XDocument xml = XDocument.load(filepath);
            IRuntimeDatabaseConfiguration conf = provider.createEmptyIntegrationDatabaseConfiguration().getRuntimeDatabaseConfiguration();
            Deserializers.getForRuntime().deserialize(xml.getRoot(), conf);
            return conf;
        }
        
        public final IRuntimeDatabaseConfiguration load(String configFileSuffix) throws ConfigurationSerializationException, IOException, javax.xml.stream.XMLStreamException, UnsupportedOperationException {
            String configFilePath = configurationFilePath(configFileSuffix);
            return StringUtils.equals(configFilePath, null) ? null : loadConfiguration(configFilePath);
        }
        
        public TypeInformation<?> getTypeInformation() {
            return TypeInformation.<ConfigurationLoader<TDatabaseProvider, TDatabaseProviderTestCase>>get(ConfigurationLoader.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        private final void instanceInitConfigurationLoader(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            this.classTypeArg_TDatabaseProvider = classTypeArg_TDatabaseProvider;
            this.classTypeArg_TDatabaseProviderTestCase = classTypeArg_TDatabaseProviderTestCase;
            provider = ClassUtils.getDefaultValue(classTypeArg_TDatabaseProvider);
        }
        protected static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void staticInitConfigurationLoader(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        }
        protected TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider;
        protected TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase;
    }
    
    private static class TestCaseConfiguration<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> implements IGenericObject {
        private String _name;
        private IRuntimeDatabaseConfiguration _run;
        private IRuntimeDatabaseConfiguration _bootstrap;
        public final String getName()
        {
            return _name;
        }
        
        public final void setName(String value)
        {
            _name = value;
        }
        public final IRuntimeDatabaseConfiguration getRun()
        {
            return _run;
        }
        
        public final void setRun(IRuntimeDatabaseConfiguration value)
        {
            _run = value;
        }
        public final IRuntimeDatabaseConfiguration getBootstrap()
        {
            return _bootstrap;
        }
        
        public final void setBootstrap(IRuntimeDatabaseConfiguration value)
        {
            _bootstrap = value;
        }
        public TestCaseConfiguration(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            instanceInitTestCaseConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        public TypeInformation<?> getTypeInformation() {
            return TypeInformation.<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>get(TestCaseConfiguration.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        private final void instanceInitTestCaseConfiguration(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            this.classTypeArg_TDatabaseProvider = classTypeArg_TDatabaseProvider;
            this.classTypeArg_TDatabaseProviderTestCase = classTypeArg_TDatabaseProviderTestCase;
        }
        protected static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void staticInitTestCaseConfiguration(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        }
        protected TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider;
        protected TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase;
    }
    
    private static class SQLScriptLoader<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> implements IGenericObject {
        private String scriptsNameSuffix;
        
        public SQLScriptLoader(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, String scriptsNameSuffix){
            staticInitSQLScriptLoader(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
            instanceInitSQLScriptLoader(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
            this.scriptsNameSuffix = scriptsNameSuffix;
        }
        
        private final String scriptFilePath(String directoryToSearch) {
            File directory = new File(directoryToSearch);
            for (File file : FileUtils.getFiles( directory )) {
                if (file.getName().endsWith(scriptsNameSuffix))
                {
                    return file.getAbsolutePath();
                }
            }
            return null;
        }
        
        private final Iterable<String> loadScript(String path) throws FileNotFoundException, IOException {
            {
                InputStreamReader reader = new InputStreamReader(new FileInputStream(path) );
                try 
                {
                    ArrayList<String> statements = new ArrayList<String>();
                    String line;
                    while (!StringUtils.equals((line = StreamUtils.readLine(reader)), null))
                    {
                        if (line.trim().length() == 0)
                        {
                            continue;
                        }
                        statements.add(line);
                    }
                    return statements;
                }
                finally {
                    if (reader!= null) {
                        reader.close();
                    }
                }
            }
        }
        
        public final Iterable<String> load(String directoryToSearch) throws FileNotFoundException, IOException {
            String scriptFilePath = scriptFilePath(directoryToSearch);
            return StringUtils.equals(scriptFilePath, null) ? null : loadScript(scriptFilePath);
        }
        
        public TypeInformation<?> getTypeInformation() {
            return TypeInformation.<SQLScriptLoader<TDatabaseProvider, TDatabaseProviderTestCase>>get(SQLScriptLoader.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        private final void instanceInitSQLScriptLoader(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            this.classTypeArg_TDatabaseProvider = classTypeArg_TDatabaseProvider;
            this.classTypeArg_TDatabaseProviderTestCase = classTypeArg_TDatabaseProviderTestCase;
        }
        protected static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void staticInitSQLScriptLoader(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        }
        protected TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider;
        protected TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase;
    }
    
    private static class TestCaseScripts<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> implements IGenericObject {
        private Iterable<String> _bootstrap;
        private Iterable<String> _teardown;
        public final Iterable<String> getBootstrap()
        {
            return _bootstrap;
        }
        
        public final void setBootstrap(Iterable<String> value)
        {
            _bootstrap = value;
        }
        public final Iterable<String> getTeardown()
        {
            return _teardown;
        }
        
        public final void setTeardown(Iterable<String> value)
        {
            _teardown = value;
        }
        public TestCaseScripts(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            instanceInitTestCaseScripts(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        public TypeInformation<?> getTypeInformation() {
            return TypeInformation.<TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase>>get(TestCaseScripts.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        private final void instanceInitTestCaseScripts(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            this.classTypeArg_TDatabaseProvider = classTypeArg_TDatabaseProvider;
            this.classTypeArg_TDatabaseProviderTestCase = classTypeArg_TDatabaseProviderTestCase;
        }
        protected static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void staticInitTestCaseScripts(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        }
        protected TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider;
        protected TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase;
    }
    
    protected static class TestSettings<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> implements IGenericObject {
        
        private static String getJarName() throws FileNotFoundException {
            String path = BaseDatabaseProviderTestConfiguration.class.getResource(BaseDatabaseProviderTestConfiguration.class.getSimpleName() + ".class").getFile();
            if(path.startsWith("/")) {
                throw new FileNotFoundException("This is not a jar file: \n" + path);
            }
        
            path = path.substring(0, path.lastIndexOf('!'));
            path = path.substring(0, path.lastIndexOf(".jar"));
            path = path.substring(path.lastIndexOf('/') + 1);
        
            return path;
        }
        
        private static Properties properties;
        private static void loadProperties() throws FileNotFoundException, IOException {
            if(properties != null) {
                return;
            }
            properties = new Properties();
            FileInputStream reader = null;
            try {
                reader = new FileInputStream(getJarName() + ".properties");
                properties.load(reader);
            } finally {
                if(reader != null) {
                    reader.close();
                }
            }
        }
        public static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> String get(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, String settingKey) throws FileNotFoundException, IllegalStateException, IOException {
            staticInitTestSettings(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
            loadProperties();String value = properties.getProperty(settingKey);if (StringUtils.isNullOrEmpty(value))
            {
                throw new IllegalStateException("Could not find " + settingKey + " in configuration file");
            }
            return value;
        }
        public TestSettings(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            instanceInitTestSettings(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        public TypeInformation<?> getTypeInformation() {
            return TypeInformation.<TestSettings<TDatabaseProvider, TDatabaseProviderTestCase>>get(TestSettings.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        }
        
        private final void instanceInitTestSettings(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            this.classTypeArg_TDatabaseProvider = classTypeArg_TDatabaseProvider;
            this.classTypeArg_TDatabaseProviderTestCase = classTypeArg_TDatabaseProviderTestCase;
        }
        protected static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void staticInitTestSettings(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        }
        protected TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider;
        protected TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase;
    }
    
    private static final String CONFIG_FILE_EXTENSION = "_JAVA.config";
    private static final String BOOTSTRAP_CONFIG_FILE = "bootstrap" + CONFIG_FILE_EXTENSION;
    private static final String BASE_CONFIGURATION_FILES_SETTING = "DatabaseProviderTests.BaseFilesPath";
    private static final String SQLSCRIPT_FILE_EXTENSION = ".sql";
    private static final String TEARDOWN_FILE_SUFFIX = "_teardown" + SQLSCRIPT_FILE_EXTENSION;
    private static final String BOOTSTRAP_FILE_SUFFIX = "_bootstrap" + SQLSCRIPT_FILE_EXTENSION;
    
    private static final <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> Pattern getConfigParamRegexField(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticsHandler = staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        return staticsHandler.configParamRegexField;
    }
    
    private static final <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void setConfigParamRegexField(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, Pattern value) {
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticsHandler = staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        staticsHandler.configParamRegexField = value;
    }
    
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> Map<Class<?>, Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>> getTestCasesField(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticsHandler = staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        return staticsHandler.testCasesField;
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void setTestCasesField(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, Map<Class<?>, Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>> value) {
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticsHandler = staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        staticsHandler.testCasesField = value;
    }
    
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> Map<String, Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>> getProviderConfigurationsField(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticsHandler = staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        return staticsHandler.providerConfigurationsField;
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> void setProviderConfigurationsField(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, Map<String, Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>> value) {
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticsHandler = staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        staticsHandler.providerConfigurationsField = value;
    }
    
    
    public Iterable<?> getValues()
    {
        return getTestCases();
    }
    
    protected abstract String getConfigurationPathSettingName();
    
    protected abstract Iterable<TDatabaseProvider> getProvidersToTest();
    
    protected boolean isRunWithBootstrapUser()
    {
        return false;
    }
    
    protected boolean isExecuteScriptsWithoutTransaction()
    {
        return false;
    }
    
    private final Iterable<IDatabaseProviderTestCase<TDatabaseProvider>> loadTestCasesFor(TDatabaseProvider provider) throws ConfigurationSerializationException, FileNotFoundException, IllegalStateException, IOException, javax.xml.stream.XMLStreamException, UnsupportedOperationException {
        return new Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>() {
            TDatabaseProvider provider;
            
            public Iterable<IDatabaseProviderTestCase<TDatabaseProvider>> setup(TDatabaseProvider provider) {
                this.provider = provider;
                return this;
            }
            public Iterator<IDatabaseProviderTestCase<TDatabaseProvider>> iterator() {
                return new Yielder<IDatabaseProviderTestCase<TDatabaseProvider>>() {
                    ArrayList<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>> configs;
                    TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase> script;
                    java.util.Iterator<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>> configIter;
                    TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase> config;
                    
                    TDatabaseProviderTestCase testCase;
                    TDatabaseProvider provider;
                    
                    public Yielder<IDatabaseProviderTestCase<TDatabaseProvider>> setup(TDatabaseProvider provider) {
                        this.provider = provider;
                        return this;
                    }
                    
                    protected boolean advance() throws Exception
                    {
                        switch (currentStatement) {
                            case BEGIN:
                                configs = LinqMethods.toList(configurationsFor(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, provider));
                                script = scriptsFor(provider);
                                configIter = (configs).iterator();
                            default:
                                while (skipLoopCondition || (configIter.hasNext())) {
                                    if (!skipLoopCondition) {
                                        config = configIter.next();
                                    }
                                    switch (currentStatement) {
                                        default:
                                            testCase = classTypeArg_TDatabaseProviderTestCase.newInstance();
                                            testCase.setName( provider.getProperties().getDisplayName() + " with conf " + config.getName() );
                                            testCase.initializeServices(provider, config.getRun(), config.getBootstrap(), isRunWithBootstrapUser());
                                            
                                            // The placeholders should be replaced with the configuration of runtime... because of the grants for the runtime user...
                                            testCase.setBootstrapScripts( processScripts(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, script.getBootstrap(), config.getRun()) );
                                            testCase.setTeardownScripts( processScripts(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, script.getTeardown(), config.getRun()) );
                                            testCase.setExecuteScriptsWithoutTransaction( isExecuteScriptsWithoutTransaction() );
                                            return yieldReturn(testCase, STATEMENT_1, SKIP_LOOP_CONDITION);
                                        case STATEMENT_1:
                                            resetControlVariables();
                                    }
                                }
                        }
                        return yieldBreak();
                    }
                }.setup(provider);
            }
        }.setup(provider);
    }
    
    private final TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase> scriptsFor(TDatabaseProvider provider) throws FileNotFoundException, IllegalStateException, IOException {
        Iterable<String> coalescetemp;
        Iterable<String> coalescetemp1;
        String pluginKey = provider.getKey().serialize();
        
        final RefParmHolder<String> baseScriptsDir = new RefParmHolder<String>(FileUtils.combine(getBaseConfigurationDirectory(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase), pluginKey));
        final RefParmHolder<String> specificScriptsDir = new RefParmHolder<String>(FileUtils.combine(getTestConfigurationDirectory(), pluginKey));
        
        Func.Func1<String, Iterable<String>> tryLoadScripts = 
            new Func.Func1<String, Iterable<String>>() {
                protected Iterable<String> executeImpl(String scriptFileSuffix) throws Exception
                {
                    SQLScriptLoader<TDatabaseProvider, TDatabaseProviderTestCase> loader = new SQLScriptLoader<TDatabaseProvider, TDatabaseProviderTestCase>(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, scriptFileSuffix);
                    Iterable<String> scripts = null;
                    if (FileUtils.directoryExists(specificScriptsDir.getVal()))
                    {
                        scripts = loader.load(specificScriptsDir.getVal());
                    }
                    if (scripts == null && FileUtils.directoryExists(baseScriptsDir.getVal()))
                    {
                        scripts = loader.load(baseScriptsDir.getVal());
                    }
                    return scripts;
                }
            };
        
        return new IObjectInitializer<TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase>>() {
                public TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase> setup(TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase> obj, Iterable<String> bootstrap, Iterable<String> teardown) {
                    obj.setBootstrap(bootstrap);
                    obj.setTeardown(teardown);
                    return obj;
                }
            }.setup(new TestCaseScripts<TDatabaseProvider, TDatabaseProviderTestCase>(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase), ((coalescetemp = tryLoadScripts.execute(BOOTSTRAP_FILE_SUFFIX)) != null ? coalescetemp : LinqMethods.empty(TypeInformation.String)), ((coalescetemp1 = tryLoadScripts.execute(TEARDOWN_FILE_SUFFIX)) != null ? coalescetemp1 : LinqMethods.empty(TypeInformation.String)));
        
    }
    
    protected final String getTestConfigurationDirectory() throws FileNotFoundException, IllegalStateException, IOException
    {
        return TestSettings.get(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, getConfigurationPathSettingName());
    }
    
    public final Iterable<IDatabaseProviderTestCase<TDatabaseProvider>> getTestCases()
    {
        RefParmHolder<Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>> result = new RefParmHolder<Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>>();
        Class<?> selfType = getClass();
        
        if (!CollectionUtils.tryGetValueFromMap(TypeInformation.<Class<?>>get(Class.class), TypeInformation.<Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>>get(Iterable.class, TypeInformation.<IDatabaseProviderTestCase<TDatabaseProvider>>get(IDatabaseProviderTestCase.class, classTypeArg_TDatabaseProvider)),getTestCasesField(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase),selfType,result))
        {
            result.setVal(LinqMethods.toList(LinqMethods.selectMany(getProvidersToTest(), 
                new Func.Func1<TDatabaseProvider, Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>>() {
                    protected Iterable<IDatabaseProviderTestCase<TDatabaseProvider>> executeImpl(TDatabaseProvider p) throws Exception
                    {
                        return loadTestCasesFor(p);
                    }
                })) );
            CollectionUtils.addToMap(getTestCasesField(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase),selfType,result.getVal());
        }
        
        return result.getVal();
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>> configurationsFor(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, TDatabaseProvider provider) throws ConfigurationSerializationException, FileNotFoundException, IllegalStateException, IOException, javax.xml.stream.XMLStreamException, UnsupportedOperationException {
        staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        String providerKey = provider.getKey().serialize();
        RefParmHolder<Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>> result = new RefParmHolder<Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>>();
        
        if (CollectionUtils.tryGetValueFromMap(TypeInformation.String, TypeInformation.<Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>>get(Iterable.class, TypeInformation.<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>get(TestCaseConfiguration.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase)),getProviderConfigurationsField(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase),providerKey,result))
        {
            return result.getVal();
        }
        else
        {
            List<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>> resultList = new ArrayList<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>();
            String configurationsPath = FileUtils.combine(getBaseConfigurationDirectory(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase), providerKey);
            
            if (FileUtils.directoryExists(configurationsPath))
            {
                File configDir = new File(configurationsPath);
                
                for (File dir : FileUtils.getDirectories( configDir )) {
                    ConfigurationLoader<TDatabaseProvider, TDatabaseProviderTestCase> loader = new ConfigurationLoader<TDatabaseProvider, TDatabaseProviderTestCase>(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, provider, dir.getAbsolutePath());
                    
                    IRuntimeDatabaseConfiguration runConfig = loader.load(providerKey + CONFIG_FILE_EXTENSION);
                    IRuntimeDatabaseConfiguration bootstrapConfig = loader.load(BOOTSTRAP_CONFIG_FILE);
                    
                    if (runConfig == null)
                        continue;
                    
                    resultList.add(new IObjectInitializer<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>() {
                            public TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase> setup(TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase> obj, String name, IRuntimeDatabaseConfiguration run, IRuntimeDatabaseConfiguration bootstrap) {
                                obj.setName(name);
                                obj.setRun(run);
                                obj.setBootstrap(bootstrap);
                                return obj;
                            }
                        }.setup(new TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase), dir.getName(), runConfig, (bootstrapConfig != null? bootstrapConfig : runConfig)));
                }
            }
            
            CollectionUtils.addToMap(getProviderConfigurationsField(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase),providerKey,resultList);
            return resultList;
        }
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> String getBaseConfigurationDirectory(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) throws FileNotFoundException, IllegalStateException, IOException
    {
        staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        return TestSettings.get(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, BASE_CONFIGURATION_FILES_SETTING);
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> Iterable<String> processScripts(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, Iterable<String> scripts, final IRuntimeDatabaseConfiguration config) {
        staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        return LinqMethods.select(scripts, 
            new Func.Func1<String, String>() {
                protected String executeImpl(String script) throws Exception
                {
                    return replace(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, script, getConfigParamRegexField(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase), 
                        new MatchEvaluator() {
                            protected String executeImpl(Match m) throws Exception
                            {
                                return processScript(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, m, config);
                            }
                        });
                }
            });
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> String processScript(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, Match match, IRuntimeDatabaseConfiguration config) throws Exception {
        staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        String configParamName = StringUtils.substring(match.group(1).getValue(), 1, match.group(1).getValue().length() - 2);
        IParameter param = new MetaDatabaseConfiguration(config).getParameter(configParamName);
        if (param == null)
        {
            throw new Exception("Configuration parameter '" + configParamName + "' used in SQL script was not found in the configuration.");
        }
        return param.get();
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> String replace(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, String sql, Pattern regex, MatchEvaluator matchEval) {
        staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        int fixup = 0;
        MatchCollection mc = RegexUtils.matches(regex, sql);
        for( int i = 0; i < mc.size(); i++)
        {
            String s = matchEval.execute(mc.get(i));
            sql = replaceSpan(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase, sql, mc.get(i).start() + fixup, mc.get(i).length(), s);
            fixup += s.length() - mc.get(i).getValue().length();
        }
        return sql;
    }
    
    private static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> String replaceSpan(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase, String sql, int start, int length, String replaceWith) {
        staticInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        return StringUtils.substring(sql, 0, start) + replaceWith + sql.substring(start + length);
    }
    public BaseDatabaseProviderTestConfiguration(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        instanceInitBaseDatabaseProviderTestConfiguration(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
    }
    
    public TypeInformation<?> getTypeInformation() {
        return TypeInformation.<BaseDatabaseProviderTestConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>get(BaseDatabaseProviderTestConfiguration.class, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
    }
    
    private final void instanceInitBaseDatabaseProviderTestConfiguration(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        this.classTypeArg_TDatabaseProvider = classTypeArg_TDatabaseProvider;
        this.classTypeArg_TDatabaseProviderTestCase = classTypeArg_TDatabaseProviderTestCase;
    }
    protected static <TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> staticInitBaseDatabaseProviderTestConfiguration(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
        @SuppressWarnings("unchecked")
        BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider, TDatabaseProviderTestCase> result = StaticsHandlerFactory.get(BaseDatabaseProviderTestConfigurationStaticsHandler.class, BaseDatabaseProviderTestConfigurationStaticsHandler.staticsHandlerMap, classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
        
        if (!result.isInitialized()) {
            synchronized (result) {
                if (result.isNew()) {
                    result.startInitialization();
                    try {
                        result.staticInit(classTypeArg_TDatabaseProvider, classTypeArg_TDatabaseProviderTestCase);
                    } finally {
                        result.finishInitialization();
                    }
                }
            }
        }
        
        return result;
    }
    protected TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider;
    protected TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase;
    private static final class BaseDatabaseProviderTestConfigurationStaticsHandler<TDatabaseProvider extends IDatabaseProvider, TDatabaseProviderTestCase extends IDatabaseProviderTestCase<TDatabaseProvider>> extends StaticsHandler {
        @SuppressWarnings("rawtypes")
        public static final java.util.Map<TypeArguments, BaseDatabaseProviderTestConfigurationStaticsHandler> staticsHandlerMap = new java.util.HashMap<TypeArguments, BaseDatabaseProviderTestConfigurationStaticsHandler>();
        public Pattern configParamRegexField;
        public Map<Class<?>, Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>> testCasesField;
        public Map<String, Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>> providerConfigurationsField;
        public void staticInit(final TypeInformation<TDatabaseProvider> classTypeArg_TDatabaseProvider, final TypeInformation<TDatabaseProviderTestCase> classTypeArg_TDatabaseProviderTestCase) {
            configParamRegexField = Pattern.compile("([%]\\w+[%])", 0 | /*unsupported: RegexOptions.CultureInvariant*/ 0);
            testCasesField = new HashMap<Class<?>, Iterable<IDatabaseProviderTestCase<TDatabaseProvider>>>();
            providerConfigurationsField = new HashMap<String, Iterable<TestCaseConfiguration<TDatabaseProvider, TDatabaseProviderTestCase>>>();
        }
    }
    
}
