/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.databaseabstractionlayer.adoadapters;

import java.io.IOException;
import java.io.InputStream;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import outsystems.hubedition.util.ExceptionUtils;
import outsystems.hubedition.util.IDisposable;
import outsystems.hubedition.util.OSResultSet;
import outsystems.hubedition.util.RefParmHolder;
import outsystems.hubedition.util.RefParmHolderInteger;
import outsystems.runtimecommon.OSTrace;

/**
 * A database command (SELECT, INSERT, etc). The command text uses the .Net
 * syntax for identifying parameters. E.g.: "SELECT * FROM TABLE WHERE USER_ID = &#64;USER_ID"
 * The look behind is there to not collect dblinks (SELECT * FROM TABLE@DBLINK or SELECT * FROM "TABLE"@DBLINK)
 * white spaces are allowed between table name and link, but we don't verify them because of statements like these 
 * select @systemCatalogLogical where select is not clearly a table name.
 */
public class ADOCommand implements IDisposable {
	private static Pattern parameterPattern = Pattern.compile("(?<![\\w\"])(@\\w+)|'|@@");

	private Connection conn;

	private String commandText;

	private ADOTransaction trans;

	private int timeout = 30;

	private ArrayList<String> parameters;

	private HashMap<String, ADOParameter> parameterValues = new HashMap<String, ADOParameter>();

	private String preparedCommandText;

	private CallableStatement preparedStatement;

	private Statement statement;

	private static short _resultSetFetchSize = 100;
	
	protected ResultSet getResultSet(CallableStatement statement, int javaParameterIndex) throws SQLException {
        return (ResultSet) statement.getObject(javaParameterIndex);
    }
    
    protected OSResultSet createReader(ResultSet resultSet, Statement executedStatement) {
	    return new ADOReader(resultSet, executedStatement);
	}

	protected OSResultSet transformJavaResultSetInOsResultSet(ResultSet resultSet, Statement executedStatement) {
	    boolean returnEmptySet = false;
        try {
            if (resultSet != null) {
                ResultSetMetaData metaData = resultSet.getMetaData();
                // if has no metadata -> not a SELECT
                if (metaData == null || (metaData.getColumnCount() == 0)) { 
                    returnEmptySet = true;
                }
            }
        } catch (SQLException sqlException) {
            // if error on getMetaData -> not a SELECT
            returnEmptySet = true;
        }
        if (returnEmptySet) {
            cleanUp();
            return new EmptyResultSet(executedStatement);
        } else {
            // is a SELECT
            if (resultSet != null) {
                return createReader(resultSet, executedStatement);
            } else {
                return new EmptyResultSet(executedStatement);
            }
        }
	}
    
	protected Statement executeStatement(RefParmHolderInteger updateCount, RefParmHolder<OSResultSet> resultSet, boolean needResultSet, 
	        boolean getOutputParameterValues) throws SQLException {

	    updateCount.setVal(-1);        
        
        try {
            Statement executedStatement;
            
            if (preparedCommandText == null) {
                statement = conn.createStatement();
                executedStatement = statement;
            } else {
                setParameters();
                executedStatement = preparedStatement;
            }
            
            executedStatement.setQueryTimeout(timeout);
            
            if (needResultSet) {
                executedStatement.setFetchSize(_resultSetFetchSize);
            }
            
            boolean nextResultIsResultSet;
            
            try {
                if (preparedCommandText == null) {
                    nextResultIsResultSet = statement.execute(commandText);
                } else {
                    nextResultIsResultSet = preparedStatement.execute();
                }
            } finally {
                freeTemporaryLobParameters();
            }
            
            if (getOutputParameterValues) {
                getAllOutputParameterValues();
            }
            
            ResultSet executedStatementJavaResultSet = null;
            
            for (;;) {      
                if (nextResultIsResultSet) {
                    executedStatementJavaResultSet = executedStatement.getResultSet();
                                    
                    if (needResultSet) {
                        break; // Already got what we want...
                    }
                } else {                    
                    updateCount.setVal(executedStatement.getUpdateCount());               
                                    
                    if (updateCount.getVal() == -1) {
                        // No more results...
                        break;
                    }
                    
                    if (!needResultSet) {
                        break; // Already got what we want...
                    }
                }
                
                nextResultIsResultSet = executedStatement.getMoreResults();
            }
            
            resultSet.setVal(transformJavaResultSetInOsResultSet(executedStatementJavaResultSet, executedStatement));
            return executedStatement;
        } catch (SQLException e) {
            cleanUp();
            throw e;
        } finally {
            if (!needResultSet) {
                cleanUp();                
            }
        }
    }
        
    /**
	 * Creates a new command owned by the connection conn.
	 * 
	 * @param conn
	 */
	public ADOCommand(Connection conn) {
		this.conn = conn;
	}

	public void setConnection(Connection conn) {
		cleanUp();
		if (this.conn != null) {
			try {
			    ConnectionUtils.closeConnection(this.conn);
			} catch (SQLException e) { }
		}
		this.conn = conn;
	}

	/**
	 * Sets the command text. The command text uses the .Net syntax for
	 * identifying parameters. E.g.: "SELECT * FROM TABLE WHERE USER_ID = &#64;USER_ID"
	 * 
	 * @param commandText The text with the instructions to be added to the command.
	 */
	public void setCommandText(String commandText) {
		this.commandText = commandText;
		parseCommandText();
	}

	
	/**
	 * Cleans up the db command so that it can be re-executed
	 */
	public void cleanUp() {
		cleanUpPreparedStatement();
		cleanUpStatement();
	}
	
	/**
	 * Cleans up the db command so that it can be re-executed
	 */
	private void cleanUpPreparedStatement() {
		if (preparedStatement != null) {
			try {
				ResultSet rs = preparedStatement.getResultSet();
				if (rs != null) {
					rs.close();
					rs = null;
				}
			} catch (Exception e) { }
			try {
				preparedStatement.close();
			} catch (SQLException e) { }
		}
		preparedStatement = null;
	}
	
	/**
	 * Cleans up the db command so that it can be re-executed
	 */
	private void cleanUpStatement() {
		if (statement != null) {
			try {
				ResultSet rs = statement.getResultSet();
				if (rs != null) {
					rs.close();
					rs = null;
				}
			} catch (Exception e) { }
			try {
				statement.close();
			} catch (SQLException e) { }
		}
		statement = null;
	}
	
	/**
	 * Gets the command text.
	 * 
	 * @return The text with the instructions to be added to the command.
	 */
	public String getCommandText() {
		return commandText;
	}
	
	public void setCommandType(int cmdType) {}		

	// prepares the underlying database statement. This is only done if the
	// command text
	// contains parameters.
	private void parseCommandText() {
		cleanUp();
		
		if (commandText.indexOf("@") == -1) {
			return;
		}
		
		parameters = new ArrayList<String>();

		// Translates the command text, which is using .Net syntax, to the syntax
		// required by JDBC. The order by which parameters appear in the original
		// query is stored so that parameters can be set by their position
		Matcher matcher = parameterPattern.matcher(commandText);
		StringBuffer sb = new StringBuffer();
		boolean insideString = false;
		while (matcher.find()) {
			String match = matcher.group();
			if (match.equals("'")) {
				insideString = !insideString;
				matcher.appendReplacement(sb, match);
			} else {
				if (insideString || match.equals("@@")) {
					matcher.appendReplacement(sb, match);
				} else {
					parameters.add(match.toLowerCase());
					matcher.appendReplacement(sb, "?");
				}
			}
		}
		matcher.appendTail(sb);		
		preparedCommandText = sb.toString();			
	}

	// Set the prepared statement with the current parameter values
	private void setParameters() throws SQLException {
		if (preparedStatement == null) {
			preparedStatement = conn.prepareCall(preparedCommandText);
		}

		for (int i = 0; i < parameters.size(); i++) {
			String parameterName = parameters.get(i);
			ADOParameter parameter = getParameter(parameterName);
			if (parameter == null) {
				throw new SQLException("Parameter " + parameterName + " has not been created");
			}
			parameter.set(preparedStatement, i + 1);
		}

		preparedStatement.setQueryTimeout(timeout);
	}
	
	
	/**
	 * Frees any temporary lob parameter created for the command's execution
	 * @throws SQLException 
	 */
	private void freeTemporaryLobParameters() {
	    try {
	        for (ADOParameter parameter: parameterValues.values()) {
    		    parameter.freeTemporaryLobs();
    		}
	    } catch (Exception e) {
		    OSTrace.warning("Error when trying to free the temporary lob parameters. Exception: {0}", ExceptionUtils.toString(e));
		}
	}

	/**
	 * Executes the command.
	 * @return Number of results 
	 * @throws SQLException 
	 */
	public int execute() throws SQLException {		
	    RefParmHolderInteger updateCount = new RefParmHolderInteger();
		executeStatement(updateCount, new RefParmHolder<OSResultSet>(), false, true);
		return updateCount.getVal();
	}
	
	/**
	 * Executes a command returning a scalar value.
	 * @return A scalar value returned by the query.
	 * @throws SQLException
	 */
	public Object executeScalar() throws SQLException {
		OSResultSet rs = executeQuery();
		Object result = null;
		try {
			if (rs.next()) {
				result = rs.getObject(1);
			}
			rs.close();
		} finally {
			cleanUp();
		}
		return result;
	}

	/**
	 * Set the command's transaction.
	 * 
	 * @param trans Transaction associated to the command.
	 */
	public void setTransaction(ADOTransaction trans) {
		this.trans = trans;
	}

	/**
	 * Gets the command's transaction.
	 * 
	 * @return The transaction associated to the Command.
	 */
	public ADOTransaction getTransaction() {
		return trans;
	}

	/**
	 * Creates a parameter. The parameter is not associated with the command
	 * until the addParameter method is called. Parameter objects are used to
	 * provide the values to the parameters specified in the command text.
	 * 
	 * @return The created parameter.
	 */
	public ADOParameter createParameter() {
	    return new ADOParameter();
	}
	
	/**
	 * Adds a parameter to the command parameters collection. Parameters may be
	 * added by any order - it is not necessary to follow the order by which
	 * they appear in the command text. A parameter should be added only once
	 * even if it appears several times in the command text (if added more than
	 * once, only the last added one is considered).
	 * 
	 * @param parameter Parameter to be added to the command.
	 */
	public void addParameter(ADOParameter parameter) {
		parameterValues.put(parameter.getName().toLowerCase(), parameter);
	}

	/**
	 * Gets the parameter with the given name from the command's parameters
	 * collection.
	 * 
	 * @param parameterName Parameter's name.
	 * @return The parameter with the given name.
	 */
	public ADOParameter getParameter(String parameterName) {
		return parameterValues.get(parameterName.toLowerCase());
	}

	/**
	 * Gets the command's parameter collection.
	 * 
	 * @return The command's parameter collection.
	 */
	public HashMap<String, ADOParameter> getParameters( ) {
		return parameterValues;
	}	
	
	/**
	 * Clears the command's parameter collection.
	 *  
	 */
	public void clearParameters() {
		parameterValues.clear();
	}

	/**
	 * Checks if the command has a parameter with the given name.
	 * 
	 * @param parameterName Parameter's name.
	 * @return True is the command has a parameter with the given name.
	 */
	public boolean hasParameter(String parameterName) {
		return getParameter(parameterName) != null;
	}

	public void setCommandTimeout(int timeout) {
		this.timeout = timeout;
	}

	public int getCommandTimeout () {
		return this.timeout;
	}
	
	@Override
	public String toString() {
		if (preparedCommandText == null)
			return commandText;

		StringBuffer str = new StringBuffer(preparedCommandText);
		str.append(" [");
		Iterator<String> iter = parameterValues.keySet().iterator();
		while (iter.hasNext()) {
			String key = iter.next();
			str.append(parameterValues.get(key) + " ");
		}
		str.append("]");

		return str.toString();
	}
		
	/**
	 * Retrieves the return value of a blob output parameter
	 * @param param The parameter's name
	 * @return The value of a blob output parameter with the given name.
	 * @throws SQLException, IOException
	 */
	public byte[] getBlobOutputParameterValue(String param) throws SQLException, IOException {
		int index = parameters.indexOf(param.toLowerCase()) + 1;		
		Blob blob = preparedStatement.getBlob(index);
		
		if (blob != null) {
			try {
			    // Create the byte array to hold the data		
    	        byte[] bytes = new byte[(int)blob.length()];
    	        // read the data...
    			InputStream stream = blob.getBinaryStream();
    			stream.read(bytes);
    			stream.close();		
    			return bytes;		
			} finally {
			    blob.free();
			}
		} else {
			return null;
		}
	}
	
	/**
	 * Retrieves the return value of an output parameter.
	 * @param param The parameter name
	 * @return The value of an output parameter with the given name.
	 */
	public Object getOutputParameterValue(String param) {
		return parameterValues.get(param.toLowerCase()).getValue();
	}
	
	protected void getAllOutputParameterValues() throws SQLException {
		if (parameters != null) {
			for (int i = 0; i < parameters.size(); i++) {
				ADOParameter parameter = parameterValues.get(parameters.get(i));
				if (parameter.getDirection() == ADOParameterDirection.Output) {
					parameter.setValue(preparedStatement.getObject(i + 1));
				}
			}
		}
	}
	
	public Connection getConnection(){
		return conn;
	}
	
	public ADOParameter getParameter(int index){
		String parameterName = parameters.get(index);
		return getParameter(parameterName);
	}
	
	@Override
    public void dispose() {
        freeTemporaryLobParameters();
    }
	
	/**
     * Executes a command that returns a result set (or not).
     * @return  A result set returned by the query.
     * @throws SQLException 
     */
    public OSResultSet executeQuery() throws SQLException {
        RefParmHolder<OSResultSet> resultSet = new RefParmHolder<OSResultSet>();
        executeStatement(new RefParmHolderInteger(), resultSet, true, true);
        return resultSet.getVal();
    }

    public List<OSResultSet> executeStoredProcedure() throws SQLException {
        boolean hasOutputResultSets = false;
        HashMap<String, ADOParameter> parameters = getParameters();

        if (parameters != null) {
            for (ADOParameter parameter: getParameters().values()) {
                if ((parameter.getDirection() == ADOParameterDirection.Output) && parameter.isResultSetParameter()) {
                    hasOutputResultSets = true;
                    break;
                }
            }
        }

        RefParmHolder<OSResultSet> returnedResultSet = new RefParmHolder<OSResultSet>();
        Statement executedStatement = executeStatement(new RefParmHolderInteger(), returnedResultSet, true, !hasOutputResultSets);

        if (hasOutputResultSets) {   
            if (executedStatement.isWrapperFor(CallableStatement.class)) {
                CallableStatement statement = executedStatement.unwrap(CallableStatement.class);
                List<OSResultSet> result = new ArrayList<OSResultSet>();

                if (parameters != null) {
                    for (int i = 0; i < parameters.size(); i++) {
                        ADOParameter parameter = getParameter(i);

                        if (parameter.getDirection() == ADOParameterDirection.Output) {
                            int javaParameterIndex = i + 1; // In java, the parameters index start at 1

                            if (parameter.isResultSetParameter()) {
                                ResultSet rs = getResultSet(statement, javaParameterIndex);
                                result.add(transformJavaResultSetInOsResultSet(rs, executedStatement));
                            } else {
                                parameter.setValue(statement.getObject(javaParameterIndex));
                            }
                        }
                    }
                }

                return result;
            } else {
                getAllOutputParameterValues();
            }
        }

        return Collections.singletonList(returnedResultSet.getVal());
    }
}
