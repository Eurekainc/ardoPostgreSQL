/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.dmlservice.dmlplaceholders;

import java.text.*;
import java.util.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.dmlservice.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import java.math.BigDecimal;
import java.util.Map;


/**
 *	Represents the possible placeholders for the select SQL statement produced for simple queries, DataSets and the Get and GetForUpdate entity actions. {BeforeStatement} SELECT {AfterSelectKeyword} column, ..., column {BeforeFromKeyword} FROM {AfterFromKeyword} Entity {BeforeWhereKeyword} WHERE {AfterWhereKeyword} conditions {BeforeGroupByKeyword} GROUP BY {AfterGroupByKeyword} column, ..., column {BeforeHavingKeyword} HAVING {AfterHavingKeyword} conditions {BeforeOrderByKeyword} ORDER BY {AfterOrderByKeyword} column, ..., column {AfterStatement}
 */
public enum SelectPlaceholder implements IEnum {
    BeforeStatement,
    AfterSelectKeyword,
    BeforeFromKeyword,
    AfterFromKeyword,
    BeforeWhereKeyword,
    AfterWhereKeyword,
    BeforeGroupByKeyword,
    AfterGroupByKeyword,
    BeforeHavingKeyword,
    AfterHavingKeyword,
    BeforeOrderByKeyword,
    AfterOrderByKeyword,
    AfterStatement;
    
    public static final TypeInformation<SelectPlaceholder> TypeInfo = TypeInformation.get(SelectPlaceholder.class);
    public int getIntValue() {
        return ordinal();
    }
    
    public static String[] names() {
        return EnumUtils.getNames(values());
    }
    
    public static SelectPlaceholder getDefaultValue() {
        return BeforeStatement;
    }
    
    private static Map<Integer, SelectPlaceholder> intToEnum;
    private static Map<Integer, SelectPlaceholder> getIntToEnum() {
        if (intToEnum == null) {
            intToEnum = EnumUtils.getIntToEnumValueMap(values());
        }
        return intToEnum;
    }
    
    private static Map<String, SelectPlaceholder> lowerCaseNameToEnum;
    private static Map<String, SelectPlaceholder> getLowerCaseNameToEnum() {
        if (lowerCaseNameToEnum == null) {
            lowerCaseNameToEnum = EnumUtils.getNameToEnumValueMap(values(), /*lowerCase*/true);
        }
        return lowerCaseNameToEnum;
    }
    
    private static Map<String, SelectPlaceholder> nameToEnum;
    private static Map<String, SelectPlaceholder> getNameToEnum() {
        if (nameToEnum == null) {
            nameToEnum = EnumUtils.getNameToEnumValueMap(values(), /*lowerCase*/false);
        }
        return nameToEnum;
    }
    
    public static SelectPlaceholder valueOf(int value) {
        SelectPlaceholder result = getIntToEnum().get(value);
        if (result == null) {
            throw new IllegalArgumentException("No enum const class SelectPlaceholder with int value " + value);
        }
        return result;
    }
    
    
    public static SelectPlaceholder valueOf(String value, boolean ignoreCase) {
        if (!ignoreCase) {
            return valueOf(value);
        }
        SelectPlaceholder result = getLowerCaseNameToEnum().get(value.toLowerCase());
        if (result == null) {
            throw new IllegalArgumentException("No enum const class SelectPlaceholder." + value);
        }
        return result;
    }
    
    
    public static boolean isDefined(String value) {
        return getNameToEnum().containsKey(value);
    }
    
    public static boolean isDefined(int value) {
        return getIntToEnum().containsKey(value);
    }
}
