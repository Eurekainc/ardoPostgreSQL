/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.transactionservice;

import java.sql.*;
import java.text.*;
import java.util.*;
import linqbridge.linq.*;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.executionservice.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import outsystems.runtimecommon.log.*;
import java.math.BigDecimal;
import linqbridge.linq.LinqMethods;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOTransaction;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ConnectionUtils;
import outsystems.hubedition.extensibility.data.configurationservice.IRuntimeDatabaseConfiguration;
import outsystems.hubedition.extensibility.data.executionservice.IExecutionService;
import outsystems.hubedition.extensibility.data.IDatabaseProvider;
import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.hubedition.extensibility.data.IProviderProperties;
import outsystems.runtimecommon.CollectionsExtensions;
import outsystems.runtimecommon.log.EventLogger;
import outsystems.runtimecommon.OSTrace;



/**
 *	Represents a service to manage transactions. Extend this class to create a transaction manager.
 */
public class GenericTransactionManager implements ITransactionManager {
    private java.util.Map<?, ?> _transactionPool;
    private TransactionInfo _requestTransactionInfo;
    public static final TypeInformation<GenericTransactionManager> TypeInfo = TypeInformation.get(GenericTransactionManager.class);
    private ITransactionService transactionService;
    
    /**
	 *	This property represents the transaction pool used by this manager.
	 *	@return	The transaction pool.
	 */
    protected final java.util.Map<?, ?> getTransactionPool()
    {
        return _transactionPool;
    }
    
    /**
	 *	This property represents the transaction pool used by this manager.
	 *	@param	value	The transaction pool.
	 */
    private final void setTransactionPool(java.util.Map<?, ?> value)
    {
        _transactionPool = value;
    }
    
    /**
	 *	This property represents information about the request transaction.
	 *	@return	The request transaction information.
	 */
    protected final TransactionInfo getRequestTransactionInfo()
    {
        return _requestTransactionInfo;
    }
    
    /**
	 *	This property represents information about the request transaction.
	 *	@param	value	The request transaction information.
	 */
    protected final void setRequestTransactionInfo(TransactionInfo value)
    {
        _requestTransactionInfo = value;
    }
    
    /**
	 *	Stores information about transaction state providing methods that allow its manipulation.
	 */
    protected static class TransactionInfo {
        public static final TypeInformation<TransactionInfo> TypeInfo = TypeInformation.get(TransactionInfo.class);
        private volatile Connection _conn;
        private volatile ADOTransaction _trans;
        private volatile boolean _free;
        private volatile boolean _isReleasable;
        private volatile boolean _isPoolable;
        private DateTime _creationTime;
        private DateTime _lastChange;
        private volatile List<OSResultSet> _readers = new ArrayList<OSResultSet>();
        
        /**
		 *	Returns true if the transaction is free.
		 *	@return	True if the transaction is free, False otherwise.
		 */
        public final boolean isFree()
        {
            return _free;
        }
        
        /**
		 *	Gets the transaction creation time.
		 *	@return	The creation time.
		 */
        public final DateTime getCreationTime()
        {
            return _creationTime;
        }
        
        /**
		 *	Gets the time of the last modification to the transaction
		 *	@return	The time when the transaction was change for last.
		 */
        public final DateTime getLastChange()
        {
            return _lastChange;
        }
        
        /**
		 *	Gets the number of readers associated with the transaction.
		 *	@return	The number of readers associated.
		 */
        public final int getReaderCount()
        {
            synchronized(_readers)
            {
                return LinqMethods.count(TypeInformation.get(OSResultSet.class), LinqMethods.where(_readers, (OSResultSet r) -> {
    return !r.isClosed();
}));
            }
        }
        
        /**
		 *	This property informs if the transaction can be released.
		 *	@return	true if this instance is releasable; otherwise, false.
		 */
        public final boolean isReleasable()
        {
            return _isReleasable;
        }
        
        /**
		 *	This property informs if the transaction can be released.
		 *	@param	value	true if this instance is releasable; otherwise, false.
		 */
        public final void setIsReleasable(boolean value)
        {
            _isReleasable = value;
        }
        
        /**
		 *	This property informs if the transaction can be returned to the pool.
		 *	@return	true if this instance is poolable; otherwise, false.
		 */
        public final boolean isPoolable()
        {
            return _isPoolable;
        }
        
        /**
		 *	This property informs if the transaction can be returned to the pool.
		 *	@param	value	true if this instance is poolable; otherwise, false.
		 */
        public final void setIsPoolable(boolean value)
        {
            _isPoolable = value;
        }
        
        /**
		 *	Returns the ADOTransaction object being wrapped.
		 *	@return	The transaction.
		 */
        public final ADOTransaction getTransaction()
        {
            return _trans;
        }
        
        /**
		 *	Returns the Connection object being wrapped.
		 *	@return	The connection.
		 */
        public final Connection getConnection()
        {
            return _conn;
        }
        
        /**
		 *	TransactionInfo constructor. Whenever possible pass in the original connection variable that created the transaction instead of just (trans, trans.Connection) It appears there is a bug in ADO.NET that makes the GC delete connections that are just referenced by a transaction,  causing the later to appear as Zombie and making trans.Connection == null.  Because of that, an explicit reference is kept both to the connection and the transaction.
		 *	@param	transaction	The transaction to be used.
		 *	@param	connection	The connection to be used.
		 */
        public TransactionInfo(ADOTransaction transaction, Connection connection){
            _conn = connection;
            _trans = transaction;
            _creationTime = new DateTime();
            _lastChange = new DateTime();
            _free = true;
            _isPoolable = true;
            _isReleasable = true;
        }
        
        /**
		 *	Marks the transaction as busy and changes its LastChange time.
		 */
        public final void reserve() {
            synchronized(this)
            {
                _free = false;
                markChange();
            }
        }
        
        /**
		 *	Releases the transaction by marking it as free, changing its LastChange time time and closing all associated readers.
		 *	@throws	java.sql.SQLException	If an error occurs while releasing the transaction.
		 */
        public final void release() throws SQLException {
            synchronized(this)
            {
                _free = true;
                markChange();
                closeReaders();
            }
        }
        
        /**
		 *	Sets the last changed time to now.
		 */
        public final void markChange() {
            _lastChange = new DateTime();
        }
        
        /**
		 *	Associates a reader with the transaction. Before associating the reader, cleans-up closed readers.
		 *	@param	reader	The reader to associate
		 */
        public final void addReader(OSResultSet reader) {
            synchronized(_readers)
            {
                // Clean-up already closed data readers, to avoid memory leaks
                CollectionsExtensions.apply(TypeInformation.get(OSResultSet.class), Arrays.asList(LinqMethods.toArray(TypeInformation.get(OSResultSet.class), LinqMethods.where(_readers, (OSResultSet r) -> {
    return r.isClosed();
}))), (OSResultSet r) -> {
                    _readers.remove(r);
                });
                _readers.add(reader);
            }
        }
        
        /**
		 *	Closes all readers associated with the transaction.
		 */
        private final void closeReaders() throws SQLException {
            synchronized(_readers)
            {
                java.util.Iterator<OSResultSet> readerIter = (_readers).iterator();
                try {
                    OSResultSet reader;
                    while (readerIter.hasNext()) {
                        reader = readerIter.next();
                        if (!reader.isClosed())
                            reader.close();
                    }
                } finally {
                    CollectionUtils.dispose(readerIter);
                }
                _readers.clear();
            }
        }
        
        /**
		 *	Closes the connection associated with the transaction.
		 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
		 */
        public final void returnConnectionToPool() throws SQLException {
            if (_conn != null)
            {
                ConnectionUtils.closeConnection(_conn);
                ConnectionUtils.closeConnection(_conn);
                _trans.returnConnectionToPool();
                _conn = null;
            }
        }
    }
    
    protected final TransactionInfo getTransactionInfo(ADOTransaction trans) {
        RefParmHolderBoolean isRequestTransaction = new RefParmHolderBoolean();
        return getTransactionInfo(trans,
            isRequestTransaction);
    }
    
    protected final TransactionInfo getTransactionInfo(ADOTransaction trans, RefParmHolderBoolean isRequestTransaction) {
        if ((getRequestTransactionInfo() != null) && getRequestTransactionInfo().getTransaction().equals(trans))
        {
            isRequestTransaction.setVal(true );
            return getRequestTransactionInfo();
        }
        else
        {
            isRequestTransaction.setVal(false );
            return (TransactionInfo) getTransactionPool().get(trans);
        }
    }
    
    /**
	 *	Returns a TransactionInfo instance built with a connection and a transaction created by the associated TransactionService.
	 *	@return	A new TransactionInfo instance.
	 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
	 */
    protected final TransactionInfo buildTransactionInfo() throws SQLException {
        ADOTransaction trans;
        Connection conn;
        
        conn = getConnection();
        trans = transactionService.createTransaction(conn);
        
        return new TransactionInfo(trans, conn);
    }
    
    /**
	 *	This property represents the ITransactionService associated with this transaction manager. When setting this property, all resources are released and transactions are rolled back.
	 */
    public ITransactionService getTransactionService()
    {
        return transactionService;
    }
    
    /**
	 *	This property represents the ITransactionService associated with this transaction manager. When setting this property, all resources are released and transactions are rolled back.
	 */
    public void setTransactionService(ITransactionService value)
    {
        freeupResources(false);
        //remove from pool all transactions (they have the old connection string)
        transactionService = value;
    }
    
    /**
	 *	Gets the IExecutionService created by the associated DatabaseService.
	 *	@return	The execution service associated.
	 */
    public final IExecutionService getExecutionService()
    {
        return transactionService.getDatabaseServices().getExecutionService();
    }
    
    /**
	 *	Gets the number of busy transactions.
	 */
    public int getBusyTransactionCount()
    {
        int counter = 0;
        java.util.Iterator<?> infoIter = (getTransactionPool().values()).iterator();
        try {
            TransactionInfo info;
            while (infoIter.hasNext()) {
                info = (TransactionInfo) infoIter.next();
                if (!info.isFree())
                    counter++;
            }
        } finally {
            CollectionUtils.dispose(infoIter);
        }
        return counter;
    }
    
    /**
	 *	Returns a transaction to be used during a web request. This transaction is only committed or rolled back by invoking freeupResources.
	 *	@return	A transaction to be used in the applications.
	 */
    public ADOTransaction getRequestTransaction() throws SQLException {
        synchronized(this)
        {
            if (getRequestTransactionInfo() == null)
            {
                setRequestTransactionInfo( buildTransactionInfo() );
            }
            
            //must discard it and make a new one if the connection is null #52135
            if (getRequestTransactionInfo().getTransaction().getConnection() == null || ConnectionUtils.getConnectionState(getRequestTransactionInfo().getTransaction().getConnection()) == ConnectionState.Closed)
            {
                if (getRequestTransactionInfo().getTransaction().getConnection() != null)
                {
                    getRequestTransactionInfo().returnConnectionToPool();
                }
                setRequestTransactionInfo( null );
                while (getRequestTransactionInfo() == null)
                {
                    
                    setRequestTransactionInfo( buildTransactionInfo() );
                    
                    if (getRequestTransactionInfo().getTransaction().getConnection() == null || ConnectionUtils.getConnectionState(getRequestTransactionInfo().getTransaction().getConnection()) == ConnectionState.Closed)
                    {
                        if (getRequestTransactionInfo().getTransaction().getConnection() != null)
                        {
                            getRequestTransactionInfo().returnConnectionToPool();
                        }
                        
                        
                        // only log error in the second try
                        logException(new InvalidTransactionException("Connection in transaction is null."), new OSStackTrace(), "Releasing connection pools and retrying");
                        
                        setRequestTransactionInfo( null );
                        // retry
                        getTransactionService().releasePooledConnections("Connection in transaction is null.");
                        ThreadUtils.sleep(TransactionServiceConstants.RETRY_CONNECTION_TIME);
                    }
                }
            }
            
            getRequestTransactionInfo().markChange();
            return getRequestTransactionInfo().getTransaction();
        }
    }
    
    /**
	 *	Returns a transaction that is managed by extension developers. Extension developers explicitly commit or rollback this transaction.
	 *	@return	A committable transaction managed by the user.
	 */
    public ADOTransaction getCommitableTransaction() throws SQLException {
        TransactionInfo transInfo = addToPoolAndReserve();
        transInfo.setIsPoolable( false );
        transInfo.setIsReleasable( false );
        return transInfo.getTransaction();
    }
    
    /**
	 *	Returns a transaction with read only access suitable to iterate results.
	 *	@return	A Transaction only for read purposes.
	 */
    public ADOTransaction getReadOnlyTransaction() throws SQLException {
        if (getTransactionService().getDatabaseServices().getDatabaseConfiguration().getDatabaseProvider().getProperties().isSupportsMultipleActiveResultSets())
        {
            return getRequestTransaction();
        }
        else
        {
            //#52135 fetching pooled transactions is already protected against null connections
            return getAndReserveFromPool().getTransaction();
        }
    }
    
    protected final TransactionInfo getAndReserveFromPool() throws SQLException {
        TransactionInfo transInfo = null;
        
        while (transInfo == null)
        {
            try {
                transInfo = getAndReserveFromPoolUnchecked();
            }catch (Exception exceptionToHandle) {
                exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
                
                if (exceptionToHandle instanceof InvalidTransactionException) {
                    InvalidTransactionException e = (InvalidTransactionException)exceptionToHandle;
                    logException(e, new OSStackTrace(), "Transaction discarded from pool. Obtaining another transaction and retrying");
                    transInfo = null;
                    // retry
                } else {
                    return WrappedException.wrapExceptionIfNeeded(exceptionToHandle);
                }
            }
        }
        return transInfo;
    }
    
    protected final TransactionInfo getAndReserveFromPoolUnchecked() throws InvalidTransactionException, SQLException {
        TransactionInfo[] transactions;
        synchronized(getTransactionPool())
        {
            transactions = LinqMethods.toArray(TransactionInfo.TypeInfo, LinqMethods.cast(TransactionInfo.TypeInfo, getTransactionPool().values()));
        }
        
        for (TransactionInfo transInfo : transactions) {
            if (transInfo.isFree())
            {
                synchronized(transInfo)
                {
                    if (transInfo.isFree())
                    {
                        DateTime lastChange = transInfo.getLastChange();
                        transInfo.reserve();
                        
                        //#52135, we already have nice checks for the pooled connections
                        if (transInfo.getTransaction().getConnection() == null || ConnectionUtils.getConnectionState(transInfo.getConnection()) == ConnectionState.Closed)
                        {
                            // build exception report
                            Connection shadowConnection = transInfo.getConnection();
                            String exceptTxt = "Connection in transaction is null or closed (TransactionInfo Status: ";
                            try {
                                if (shadowConnection == null)
                                {
                                    exceptTxt += "Connection=null, ";
                                }
                                else
                                {
                                    exceptTxt += "Connection.State=='" + ConnectionUtils.getConnectionState(shadowConnection).toString() + "', ";
                                }
                                
                                exceptTxt += "Free='" + ((transInfo.isFree()) ? "True" : "False") + "', CreationTime='" + transInfo.getCreationTime() + "', LastChange='" + lastChange + "', ReaderCount='" + transInfo.getReaderCount() + "')";
                                
                                int numTransactions = transactions.length;
                                int numFree = countFreeTransactionsInPool(transactions);
                                exceptTxt += ". (Pool Status: Total=" + numTransactions + ", Free=" + numFree + ")";
                            }catch (Exception exceptionToHandle) {
                            
                        }
                         finally{
                            // remove and cleanup everything
                            getTransactionPool().remove(transInfo.getTransaction());
                            
                            transInfo.getTransaction().dispose();
                            
                            if (transInfo.getConnection() != null)
                            {
                                ConnectionUtils.closeConnection(transInfo.getConnection());
                            }
                        }
                        throw new InvalidTransactionException(exceptTxt);
                    }
                    else
                    {
                        return transInfo;
                    }
                }
            }
        }
    }
    // No free transaction found. Add a new one and return it.
    return addToPoolAndReserve();
}

protected final TransactionInfo addToPoolAndReserve() throws SQLException {
    synchronized(this)
    {
        TransactionInfo transInfo = null;
        while (transInfo == null)
        {
            transInfo = buildTransactionInfo();
            transInfo.reserve();
            
            //drivers doesn't ensure connection is good so make sure
            if (transInfo.getTransaction().getConnection() == null || ConnectionUtils.getConnectionState(transInfo.getTransaction().getConnection()) == ConnectionState.Closed)
            {
                if (transInfo.getTransaction().getConnection() != null)
                {
                    transInfo.returnConnectionToPool();
                }
                logException(new InvalidTransactionException("Connection in transaction is null."), new OSStackTrace(), "Releasing connection pools and retrying");
                transInfo = null;
                // retry;
                getTransactionService().releasePooledConnections("Connection in transaction is null.");
                ThreadUtils.sleep(TransactionServiceConstants.RETRY_CONNECTION_TIME);
            }
        }
        
        NonGeneric.put(getTransactionPool(), transInfo.getTransaction(), transInfo);
        return transInfo;
    }
}

private final int countFreeTransactionsInPool(TransactionInfo[] transactions) {
    int numFree = 0;
    for (TransactionInfo transInfoTmp : transactions) {
        if (transInfoTmp.isFree())
        {
            numFree++;
        }
    }
    return numFree;
}

/**
 *	Returns a database connection created by the associated TransactionService.
 *	@return	A new connection to the database
 *	@throws	java.sql.SQLException	If an error occurs while creating the connection.
 */
protected final Connection getConnection() throws SQLException {
    return transactionService.createConnection();
}

/**
 *	Releases a transaction to the pool. If the transaction is poolable, it is released and put back into the pool, otherwise it is removed. Throws an InvalidTransactionReleaseException if the transaction is not releasable.
 *	@param	trans	Transaction to be released.
 *	@throws	InvalidTransactionReleaseException	Occurs if the transaction is not releasable.
 */
public void releaseTransaction(ADOTransaction trans) throws InvalidTransactionReleaseException, SQLException {
    if (trans == null)
        return;
    TransactionInfo transInfo = (TransactionInfo) getTransactionPool().get(trans);
    if (transInfo != null)
    {
        if (!transInfo.isReleasable())
            throw (new InvalidTransactionReleaseException("Cannot release a transaction that was created with \"GetCommitableTransaction\". Use commit or rollback"));
        if (transInfo.isPoolable())
        {
            transInfo.release();
        }
        else
        {
            getTransactionPool().remove(trans);
        }
    }
    else
    {
        try {
            if (getRequestTransactionInfo() != null && trans == getRequestTransactionInfo().getTransaction())
            {
                //when releasing the request transaction make sure the connection is ok
                if (trans.getConnection() != null && ConnectionUtils.getConnectionState(trans.getConnection()) != ConnectionState.Open)
                {
                    logException(new InvalidTransactionException("Request transaction not open on release."), new OSStackTrace(), "Request Transaction discarded due to connection not being in a correct state.");
                    //clear and try to dispose connection
                    synchronized(this)
                    {
                        setRequestTransactionInfo( null );
                    }
                    ConnectionUtils.closeConnection(trans.getConnection());
                }
                else
                {
                    getRequestTransactionInfo().markChange();
                }
            }
        }catch (Exception exceptionToHandle) {
            {
                //this is a best effort 
            }
        }
    }
}

/**
 *	Commits a transaction. The transaction is committed, the connection is closed and put back into the pool.
 *	@param	trans	The transaction to be committed.
 */
public void commitTransaction(ADOTransaction trans) throws InvalidCommitOrRollbackTransactionException {
    endCommitableTransaction(trans, true);
}

/**
 *	Rolls back a transaction. The transaction is rolled back, the connection is closed and put back into the pool.
 *	@param	trans	Transaction to be rolled back.
 */
public void rollbackTransaction(ADOTransaction trans) throws InvalidCommitOrRollbackTransactionException {
    endCommitableTransaction(trans, false);
}


/**
 *	Commits all Request transactions.
 */
public void commitAllTransactions() throws SQLException {
    if (getRequestTransactionInfo() != null)
    {
        safeEndTransaction(getRequestTransactionInfo(), true, /*toFreeResources*/
        false);
    }
    if (getRequestTransactionInfo() != null && (getRequestTransactionInfo().getConnection() == null || getRequestTransactionInfo().getTransaction() == null || getRequestTransactionInfo().getTransaction().getConnection() == null))
    {
        getRequestTransactionInfo().returnConnectionToPool();
        setRequestTransactionInfo( null );
    }
    if (getRequestTransactionInfo() == null)
    {
        getRequestTransaction();
        // Set a new request transaction
    }
}

/**
 *	Rolls back all Request transactions.
 */
public void rollbackAllTransactions() throws SQLException {
    if (getRequestTransactionInfo() != null)
    {
        safeEndTransaction(getRequestTransactionInfo(), false, /*toFreeResources*/
        false);
    }
    if (getRequestTransactionInfo() != null && (getRequestTransactionInfo().getConnection() == null || getRequestTransactionInfo().getTransaction() == null || getRequestTransactionInfo().getTransaction().getConnection() == null))
    {
        getRequestTransactionInfo().returnConnectionToPool();
        setRequestTransactionInfo( null );
    }
    if (getRequestTransactionInfo() == null)
    {
        getRequestTransaction();
        // Set a new request transaction
    }
}

/**
 *	Ends a transaction by committing or rolling back.
 *	@param	trans	Transaction to commit.
 *	@param	commit	If True, the transaction is committed, otherwise is rolled back.
 *	@throws	outsystems.hubedition.extensibility.data.transactionservice.InvalidCommitOrRollbackTransactionException	If an error occurs while committing or rollbacking a transaction.
 */
protected final void endCommitableTransaction(ADOTransaction trans, boolean commit) throws InvalidCommitOrRollbackTransactionException {
    if (getRequestTransactionInfo() != null && getRequestTransactionInfo().getTransaction().equals(trans))
    {
        throw (new InvalidCommitOrRollbackTransactionException("Cannot " + (commit ? "commit" : "rollback") + " this transaction: Possibly already closed by a Thread"));
    }
    else
    {
        if (trans != null)
        {
            TransactionInfo transInfo = (TransactionInfo) getTransactionPool().get(trans);
            if (transInfo != null)
            {
                if (transInfo.isPoolable())
                {
                    throw new InvalidCommitOrRollbackTransactionException("Cannot " + (commit ? "commit" : "rollback") + 
                        " a transaction that was created with \"GetTransaction\". Use Release.");
                }
                
                safeEndTransaction(transInfo, commit, /*toFreeResources*/
                false);
            }
        }
    }
}

private final void safeEndTransaction(TransactionInfo transInfo, boolean commit, boolean toFreeResources) {
    try {
        endTransaction(transInfo, commit, toFreeResources);
    }catch (Exception exceptionToHandle) {
        exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
        
        {
            Exception e = (Exception)exceptionToHandle;
            EventLogger.writeError("Error closing the transaction to the database: " + ExceptionUtils.getExceptionTypeOrMessage(e) + "\n" + LogUtils.getStackTrace(e) + "\n" + new OSStackTrace(true));
        }
    }
}

/**
 *	Ends a pooled transaction, performing additional cleanup code if necessary. An error if an exception is raised.
 *	@param	transInfo	Object containing information about the transaction.
 *	@param	commit	If True, all transaction are committed. Otherwise, they are rolled back.
 *	@param	toFreeResources	If True, all resources are released and connections returned to the pool.
 *	@throws	java.sql.SQLException	If an error occurs while ending the transaction.
 */
protected void endTransaction(TransactionInfo transInfo, boolean commit, boolean toFreeResources) throws SQLException {
    getTransactionPool().remove(transInfo.getTransaction());
    transInfo.release();
    try {
        if (commit)
        {
            transInfo.getTransaction().commit();
        }
        else
        {
            transInfo.getTransaction().rollback();
        }
    } finally{
        transInfo.returnConnectionToPool();
    }
}

/**
 *	Releases all database resources being used. All transactions are committed or rolled back, and connections are returned to the pool. This implementation calls the endTransaction method to end the transactions and sets the RequestTransactionInfo to Null.
 *	@param	commit	If True, all transaction are committed. Otherwise, they are rolled back.
 */
public void freeupResources(boolean commit) {
    synchronized(getTransactionPool())
    {
        // Note: The "new ArrayList" duplicates the values because "endTransaction" deletes them.
        for (TransactionInfo transInfo : LinqMethods.toArray(TransactionInfo.TypeInfo, LinqMethods.cast(TransactionInfo.TypeInfo, getTransactionPool().values()))) {
            safeEndTransaction(transInfo, commit, /*toFreeResources*/
            true);
        }
    }
    
    synchronized(this)
    {
        if (getRequestTransactionInfo() != null)
        {
            safeEndTransaction(getRequestTransactionInfo(), commit, /*toFreeResources*/
            true);
            setRequestTransactionInfo( null );
        }
    }
}

/**
 *	Associates a reader to a transaction.
 *	@param	trans	The transaction that will be associated with the reader.
 *	@param	reader	The reader to associate.
 *	@return	Returns True if the reader was successfully associated, False otherwise.
 */
public boolean associateReader(ADOTransaction trans, OSResultSet reader) {
    TransactionInfo info = getTransactionInfo(trans);
    
    if (info != null)
    {
        info.addReader(reader);
        return true;
    }
    return false;
}

/**
 *	Logs an error with information about the exception, the stack trace and a message.
 *	@param	e	Exception to log.
 *	@param	additionalStack	Stack trace to add to the log.
 *	@param	additionalMessage	Message to add to the log.
 */
protected final void logException(Exception e, OSStackTrace additionalStack, String additionalMessage) {
    try {
        String additionalStackString = (additionalStack != null ? additionalStack.toString() : "");
        OSTrace.error((e != null ? ExceptionUtils.getExceptionTypeOrMessage(e) : "") + StringUtils.newLine + additionalMessage + 
            (e != null && !StringUtils.equals(LogUtils.getStackTrace(e), null) ? LogUtils.getStackTrace(e).toString() + (StringUtils.isNullOrEmpty(additionalStackString) ? "" : "\n" + additionalStackString) : additionalStackString));
    }catch (Exception exceptionToHandle) {
    
}
}

/**
 *	Checks if this manager is managing a given transaction. This implementation, checks if the TransactionInfo  returned by the GetTransactionInfo(System.Data.IDbTransaction) is not null.
 *	@param	trans	The transaction.
 *	@return	Returns True if the transaction belongs to this transaction manager, False otherwise.
 */
public boolean isManaging(ADOTransaction trans) {
    return getTransactionInfo(trans) != null;
}

/**
 *	Creates a new instance of the GenericTransactionManager class.
 *	@param	transactionService	The transaction service to be used.
 */
public GenericTransactionManager(ITransactionService transactionService){
    this.transactionService = transactionService;
    setTransactionPool( Collections.synchronizedMap(new HashMap<Object, Object>()) );
}

private boolean isDisposed;

/**
 *	Frees all resources and rolls back existing transactions.
 */
public final void dispose() {
    try {
        if (!isDisposed)
        {
            freeupResources(/*commit*/
            false);
        }
    }catch (Exception exceptionToHandle) {
        exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
        
        {
            Exception e = (Exception)exceptionToHandle;
            // avoid errors during dispose
            OSTrace.error("Exception on Dispose", e);
        }
    }
     finally{
        isDisposed = true;
    }
}

/**
 *	Aborts a transaction and releases it.
 *	@param	trans	Transaction to be aborted.
 */
public final void abortTransaction(ADOTransaction trans) throws SQLException {
    if (trans == null)
    {
        return;
    }
    
    RefParmHolderBoolean isRequestTransaction = new RefParmHolderBoolean();
    TransactionInfo transInfo = getTransactionInfo(trans,
        isRequestTransaction);
    
    if (transInfo != null)
    {
        transInfo.release();
        
        if (isRequestTransaction.getVal())
        {
            setRequestTransactionInfo( null );
        }
        else
        {
            getTransactionPool().remove(transInfo.getTransaction());
        }
        
        transInfo.returnConnectionToPool();
    }
}

}
