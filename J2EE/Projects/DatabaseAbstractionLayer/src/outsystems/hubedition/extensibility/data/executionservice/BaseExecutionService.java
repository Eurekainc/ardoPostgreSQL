/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.executionservice;

import java.sql.*;
import java.text.*;
import java.util.*;
import linqbridge.linq.*;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.configurationservice.*;
import outsystems.hubedition.extensibility.data.transactionservice.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import java.math.BigDecimal;
import linqbridge.linq.LinqMethods;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOCommand;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOCommandType;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOParameter;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOTransaction;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ConnectionUtils;
import outsystems.hubedition.extensibility.data.configurationservice.IRuntimeDatabaseConfiguration;
import outsystems.hubedition.extensibility.data.DBDataType;
import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.hubedition.extensibility.data.transactionservice.ITransactionManager;
import outsystems.hubedition.extensibility.data.transactionservice.ITransactionService;
import outsystems.runtimecommon.OSTrace;


/**
 *	Base implementation of a database service that handles the execution of statements made while connected to a database.
 */
public abstract class BaseExecutionService implements IExecutionService {
    private IDatabaseServices _databaseServices;
    public static final TypeInformation<BaseExecutionService> TypeInfo = TypeInformation.get(BaseExecutionService.class);
    
    private static final int TimeoutErrorCode = -2;
    
    /**
	 *	Gets the prefix used to qualify command parameters (e.g. @)
	 */
    public abstract String getParameterPrefix();
    
    /**
	 *	Method called by the consumers of this service when an execution exception occurs. It is used to handle edge cases where cleaning up is required. NOTE: This method should handle the exception and not rethrow it.
	 *	@param	e	Exception thrown during execution.
	 *	@param	cmd	Command that was running when the exception was raised.
	 *	@param	reader	Reader created from executing the command, if applicable.
	 *	@param	conn	Connection that creates the transaction where the exception occurred, if applicable.
	 *	@param	trans	Transaction where the exception was produced, if applicable.
	 *	@param	manager	Transaction manager associated with this command, if applicable.
	 */
    public void onExecuteException(java.sql.SQLException e, ADOCommand cmd, OSResultSet reader, Connection conn, ADOTransaction trans, ITransactionManager manager) throws SQLException {
        if (isConnectionException(e))
        {
            // #70408, #112391
            // When network connection is lost and later recovered to the database all previous connections in the pool
            // become unusable. Connection opening works as expected, but once used the following exception will occur:
            // - TCP Provider, error: 0 - An existing connection was forcibly closed by the remote host.
            // There is no viable workaround to this problem (except for disabling connection pooling)
            // http://social.msdn.microsoft.com/Forums/en-US/sqlnetfx/thread/4895d56b-716f-4f82-860f-0aa161d327cc/	
            // This will affect ALL connections in the connection pool.
            
            // Our workaround is to release all connections in the pool when the error happens. Although the current call
            // will fail, subsequent errors like this will be avoided since new connections will have to be opened.
            
            if(cmd.getConnection() != null) { ConnectionUtils.closeConnection(cmd.getConnection()); }
            // Close reader if open
            if (reader != null && !reader.isClosed())
            {
                reader.close();
            }
            
            if (manager != null && trans != null)
            {
                manager.abortTransaction(trans);
            }
        }
    }
    
    /**
     *	Checks if a type is String or AnsiString.
     *	@param	dbType	Database type.
     *	@return	True if it is String or AnsiString, False otherwise.
     */
    protected final boolean isStringOrAnsiStringDbType(int dbType)
    {
        return dbType == Types.VARCHAR;
    }
    
    
    /**
	 *	Sets a parameter with a database type.
	 *	@param	dbType	Database Type.
	 *	@param	param	Parameter to change.
	 */
    protected void setCorrectDBType(int dbType, ADOParameter param) {
        param.setDbType( dbType );
    }
    
    /**
     *	Set a parameter with a value.
     *	@param	param	Parameter to set the value with.
     *	@param	dbType	Database type of the parameter.
     *	@param	paramValue	Value to set.
     */
    public void setParameterValue(ADOParameter param, int dbType, Object paramValue)
    {
        if (paramValue == null) {
                        param.setValue(((Object) null));
                    }
                    else if (paramValue instanceof outsystems.hubedition.util.IEnum && dbType == Types.INTEGER) {
                        param.setValue(((outsystems.hubedition.util.IEnum)paramValue).getIntValue());
                    }
                    else {
                        param.setValue(paramValue);
                    }
    }
    
    
    /**
	 *	Checks if an exception was raised due to a connection error.
	 *	@param	e	Exception raised.
	 *	@return	True if the exception was due to a connection problem, False otherwise.
	 */
    public abstract boolean isConnectionException(java.sql.SQLException e);
    
    /**
	 *	Gets the IDatabaseServices instance associated with this service.
	 */
    public IDatabaseServices getDatabaseServices()
    {
        return _databaseServices;
    }
    
    /**
	 *	Gets the IDatabaseServices instance associated with this service.
	 */
    private void setDatabaseServices(IDatabaseServices value)
    {
        _databaseServices = value;
    }
    
    
    /**
     *	Initializes a new instance of the BaseExecutionService class.
     *	@param	databaseServices	The database services to be used with this execution service.
     */
    public BaseExecutionService(IDatabaseServices databaseServices)
    {
        setDatabaseServices( databaseServices );
                  bulkWriter = new BulkWriter(databaseServices, new BulkWriter.ADOParameterFactory() {
                	@Override
                	public ADOParameter createADOParameter() {
                		return BaseExecutionService.this.createADOParameter();
                	}
                });
    }
    
    /**
	 *	Gets the database configuration used by this service.
	 *	@return	The database configuration.
	 */
    public final IRuntimeDatabaseConfiguration getDatabaseConfiguration()
    {
        return getDatabaseServices().getDatabaseConfiguration();
    }
    
    /**
	 *	Executes a command and returns the number of affected rows. This implementation does not use the isApplication flag, and logs exceptions.
	 *	@param	cmd	The command to execute.
	 *	@return	The number of rows affected.
	 */
    public int executeNonQuery(ADOCommand cmd) throws SQLException {
        try {
            return cmd.execute();
        }catch (Exception exceptionToHandle) {
            exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
            
            if (exceptionToHandle instanceof java.sql.SQLException) {
                java.sql.SQLException e = (java.sql.SQLException)exceptionToHandle;
                OSTrace.error("Error executing ExecuteNonQuery (" + ExceptionUtils.getExceptionTypeOrMessage(e) + ") with statement:" + StringUtils.newLine + cmd.getCommandText());
                throw e;
            } else {
                return WrappedException.<Integer>wrapExceptionIfNeeded(exceptionToHandle);
            }
        }
    }
    
    /**
	 *	Executes a command and returns the resulting OSResultSet. This implementation logs exceptions.
	 *	@param	cmd	The command to execute.
	 *	@return	A reader with the results of executing the query command.
	 */
    public OSResultSet executeReader(ADOCommand cmd) throws SQLException {
        try {
            return cmd.executeQuery();
        }catch (Exception exceptionToHandle) {
            exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
            
            if (exceptionToHandle instanceof java.sql.SQLException) {
                java.sql.SQLException e = (java.sql.SQLException)exceptionToHandle;
                OSTrace.error("Error executing ExecuteReader (" + ExceptionUtils.getExceptionTypeOrMessage(e) + ") with statement:" + StringUtils.newLine + cmd.getCommandText());
                throw e;
            } else {
                return WrappedException.wrapExceptionIfNeeded(exceptionToHandle);
            }
        }
    }
    
    /**
	 *	Executes a command and returns the value of the first column of the first row in the resultset returned by the query. This implementation logs exceptions.
	 *	@param	cmd	The command to execute.
	 *	@return	An object with the resulting first row and first column of the query defined in the query command.
	 */
    public Object executeScalar(ADOCommand cmd) throws SQLException {
        try {
            return cmd.executeScalar();
        }catch (Exception exceptionToHandle) {
            exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
            
            if (exceptionToHandle instanceof java.sql.SQLException) {
                java.sql.SQLException e = (java.sql.SQLException)exceptionToHandle;
                OSTrace.error("Error executing ExecuteScalar (" + ExceptionUtils.getExceptionTypeOrMessage(e) + ") with statement:" + StringUtils.newLine + cmd.getCommandText());
                throw e;
            } else {
                return WrappedException.wrapExceptionIfNeeded(exceptionToHandle);
            }
        }
    }
    
    /**
	 *	Sets the parameter direction (Input, Output, InputOutput or ReturnValue).
	 *	@param	param	Parameter to set the direction.
	 *	@param	direction	Direction to be set.
	 */
    public void setParameterDirection(ADOParameter param, int direction) {
        param.setDirection( direction );
    }
    
    protected ADOCommand createCommand(Connection connection) throws SQLException {
        return new ADOCommand(connection);
    }
    
    
    /**
	 *	Creates an SQL command to be executed in a transaction. This implementation replaces \r\n by \n.
	 *	@param	trans	The transaction to execute the command.
	 *	@param	sql	The SQL statement to be executed.
	 *	@return	An SQL command.
	 */
    public ADOCommand createCommand(ADOTransaction trans, String sql) throws SQLException {
        ADOCommand cmd;
        cmd = createCommand(trans.getConnection());
        cmd.setTransaction( trans );
        cmd.setCommandText( StringUtils.replace(sql, "\r\n", "\n") );
        return cmd;
    }
    
    /**
	 *	Creates a transactionless command associated with the connection. This implementation does not transform the SQL statement.
	 *	@param	connection	The connection where the command is going to be executed.
	 *	@param	sql	The SQL statement to be executed.
	 *	@return	An SQL command.
	 */
    public ADOCommand createCommand(Connection connection, String sql) throws SQLException {
        ADOCommand cmd = createCommand(connection);
        cmd.setCommandText( StringUtils.replace(sql, "\r\n", "\n") );
        return cmd;
    }
    
    /**
	 *	Creates and associates a new parameter to a command. If the command already has a parameter with the same name, that parameter is returned and the command parameters are not changed.
	 *	@param	cmd	The command to associate the parameter.
	 *	@param	name	Parameter name.
	 *	@param	dbType	Parameter type.
	 *	@param	paramValue	Parameter value.
	 *	@return	The parameter already associated to the command.
	 */
    public ADOParameter createParameter(ADOCommand cmd, String name, int dbType, Object paramValue) {
        ADOParameter param = cmd.createParameter();
        param.setName( name );
        setCorrectDBType(dbType, param);
        
        if (cmd.hasParameter(name))
        {
            return (ADOParameter) cmd.getParameter(name);
        }
        
        setParameterValue(param, dbType, paramValue);
        cmd.addParameter(param);
        return param;
    }
    
    /**
	 *	Converts a type to its equivalent type in the database. This implementation matches:string to DbType.String;Int32 to DbType.Int32;DateTime to DbType.DateTime;decimal to DbType.Decimal;bool to DbType.Boolean;otherwise throws a NotSupportedException.
	 *	@param	type	The type to be converted.
	 *	@return	A supported type by the database.
	 *	@throws	UnsupportedOperationException	When no suitable type is found.
	 */
    public int convertToDbType(Class<?> type) {
        if (ClassUtils.areSameClass(type, String.class))
        {
            return Types.VARCHAR;
        }
        else if (ClassUtils.areSameClass(type, int.class))
        {
            return Types.INTEGER;
        }
        else if (ClassUtils.areSameClass(type, DateTime.class))
        {
            return Types.TIMESTAMP;
        }
        else if (ClassUtils.areSameClass(type, BigDecimal.class))
        {
            return Types.DECIMAL;
        }
        else if (ClassUtils.areSameClass(type, boolean.class))
        {
            return Types.BIT;
        }
        else if (ClassUtils.areSameClass(type, long.class))
        {
            return Types.BIGINT;
        }
        else
        {
            throw new UnsupportedOperationException("Unable to convert " + type.toString() + " to DbType");
        }
    }
    
    public SqlTypes convertToDbType(DBDataType type, String providerType) {
        switch (type) {
            case TEXT: {
                return SqlTypes.NVARCHAR;
            }
            case INTEGER: {
                return SqlTypes.INTEGER;
            }
            case LONGINTEGER: {
                return SqlTypes.BIGINT;
            }
            case DECIMAL: {
                return SqlTypes.DECIMAL;
            }
            case DATE_TIME: {
                return SqlTypes.TIMESTAMP;
            }
            case DATE: {
                return SqlTypes.DATE;
            }
            case TIME: {
                return SqlTypes.TIME;
            }
            case BOOLEAN: {
                return SqlTypes.BIT;
            }
            case BINARY_DATA: {
                return SqlTypes.BINARY;
            }
            default: {
                throw new UnsupportedOperationException("Unable to convert " + type.toString() + " to SqlTypes");
            }
        }
    }
    
    
    
    /**
     *	Checks if an exception was raised due to a timeout. This implementation checks if the exception is a java.sql.SQLException, and its error code is -2.
     *	@param	exception	Exception raised.
     *	@return	True if the exception was due to a timeout, False otherwise.
     */
    public boolean isTimeoutException(Exception exception)
    {
        return exception instanceof java.sql.SQLTimeoutException;
    }
    
    
    /**
	 *	Transforms a database value to the equivalent runtime value. This implementation returns the value without changing it.
	 *	@param	value	Value to transform.
	 *	@return	The transformed object.
	 */
    public Object transformDatabaseToRuntimeValue(Object value) {
        return value;
    }
    
    /**
	 *	Transforms a runtime value to the equivalent database value. This implementation returns the value without changing it.
	 *	@param	dbType	Database type.
	 *	@param	value	Value to transform.
	 *	@return	The transformed object.
	 */
    public Object transformRuntimeToDatabaseValue(int dbType, Object value) {
        
        if (value != null && value.equals(""))
        {
            
            int[] numericTypes = new int[] { Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.SMALLINT, Types.INTEGER, Types.BIGINT, Types.TINYINT, Types.TINYINT };
            
            int[] decimalTypes = new int[] { Types.REAL, Types.DECIMAL, Types.FLOAT, Types.DOUBLE, Types.NUMERIC };
            
            if (LinqMethods.contains(TypeInformation.get(int.class), ArrayUtils.fromIterable(decimalTypes), dbType))
            {
                return new BigDecimal(0);
            }
            
            if (LinqMethods.contains(TypeInformation.get(int.class), ArrayUtils.fromIterable(numericTypes), dbType))
            {
                return Integer.valueOf(0);
            }
        }
        
        return value;
    }
    
    
    
    private BulkWriter bulkWriter;
        
    protected ADOParameter createADOParameter() {
        return new ADOParameter();
    }
    
    /**
     *	Bulk inserts data into the database. In this base implementation data is bulk inserted falling back to individual inserts in case an error occurs.
     *	@param	datatable	A datatable with all information to transfer.
     */
    public void bulkInsert(DataTable datatable) throws SQLException
    {
        try {
            bulkWriter.bulkInsert(datatable);
        }catch(Exception e) {
            outsystems.runtimecommon.log.EventLogger.writeError(e);
            bulkWriter.individualInsert(datatable);
        }
    }
    
    
    
}
