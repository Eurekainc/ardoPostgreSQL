/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.transactionservice;

import java.sql.*;
import java.text.*;
import java.util.*;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import outsystems.runtimecommon.log.*;
import java.math.BigDecimal;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOTransaction;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ConnectionState;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ConnectionUtils;
import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.runtimecommon.log.EventLogger;
import outsystems.runtimecommon.StringUtilities;



/**
 *	Database service that handles connection and transaction management to a access a database. This is a base implementation of an abstract transaction service.
 */
public abstract class BaseTransactionService implements ITransactionService {
    private IDatabaseServices _databaseServices;
    public static final TypeInformation<BaseTransactionService> TypeInfo = TypeInformation.get(BaseTransactionService.class);
    protected final outsystems.hubedition.extensibility.data.transactionservice.ConnectionPoolBridge pool = new outsystems.hubedition.extensibility.data.transactionservice.ConnectionPoolBridge(getDriverConnectionFactoryClassName());          
    
    public abstract String getDriverConnectionFactoryClassName();
    
    /**
	 *	Gets the isolation level to be used in the transactions.
	 *	@return	The isolation level of the transactions.
	 */
    protected abstract int getIsolationLevel();
    
    protected void releaseAllPooledConnections() {}
    
    
    
    /**
	 *	Returns a new transaction manager.
	 *	@return	The transaction manager.
	 */
    public ITransactionManager createTransactionManager() {
        return new GenericTransactionManager(this);
    }
    
    /**
	 *	Checks if a separate connection is needed to connect to another catalog.
	 *	@return	True if is needed a separate admin connection. False otherwise.
	 */
    public abstract boolean isNeedsSeparateAdminConnection();
    
    
    protected Connection getConnectionFromDriver() throws SQLException {
        return pool.getConnection(getDatabaseServices().getDatabaseConfiguration().getConnectionString());
    }
    
    
    
    /**
	 *	Creates a new instance of the BaseTransactionService class.
	 *	@param	databaseServices	The database services to be used by this service.
	 */
    public BaseTransactionService(IDatabaseServices databaseServices){
        setDatabaseServices( databaseServices );
    }
    
    /**
	 *	This property represents the IDatabaseServices instance associated with this service.
	 *	@return	The database services associated.
	 */
    public IDatabaseServices getDatabaseServices()
    {
        return _databaseServices;
    }
    
    /**
	 *	This property represents the IDatabaseServices instance associated with this service.
	 *	@param	value	The database services associated.
	 */
    private void setDatabaseServices(IDatabaseServices value)
    {
        _databaseServices = value;
    }
    
    /**
	 *	Returns a new connection to the database. This implementation calls CreateConnection(int)  with the number of retries equals to DEFAULT_CONNECTION_RETRIES.
	 *	@return	The database connection.
	 */
    public Connection createConnection() throws SQLException {
        return createConnection(TransactionServiceConstants.DEFAULT_CONNECTION_RETRIES);
    }
    
    /**
	 *	Returns a new connection to the database. This implementation calls getConnectionFromDriver, opens the connection and returns it.
	 *	@param	numRetries	The number retries for establish the connection.
	 *	@return	an open database connection.
	 */
    public Connection createConnection(int numRetries) throws SQLException {
        Connection conn = null;
        int retryNumber = 0;
        
        // We make connectionCreationMaxRetries so the sql connection can be restored if a minor error happened
        while (retryNumber++ <= numRetries)
        {
            if (retryNumber != 1)
            {
                // Sleep to allow a recover of the server
                ThreadUtils.sleep(TransactionServiceConstants.RETRY_CONNECTION_TIME);
            }
            
            try {
                conn = getConnection();
                break;
            }catch (Exception exceptionToHandle) {
                exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
                
                {
                    Exception e = (Exception)exceptionToHandle;
                    // If we're here, it means that conn is null
                    String message;
                    
                    if (isNonTransientConnectionException(e))
                    {
                        message = "Error opening connection to the database: " + ExceptionUtils.getExceptionTypeOrMessage(e) + "\nNot retrying because connection will not succeed unless the cause of the failure is corrected.\n\n" + LogUtils.getStackTrace(e) + "\n" + (new OSStackTrace(true)).toString();
                        
                        EventLogger.writeError(message);
                        
                        // Since we already retried it connectionCreationMaxRetries rethrow the exception occurred
                        if (e instanceof SQLException)
                            throw (SQLException)e;
                        if (e instanceof RuntimeException)
                            throw (RuntimeException)e;
                        return WrappedException.wrapExceptionIfNeeded(e);
                    }
                    else if (retryNumber >= numRetries)
                    {
                        message = "Error opening connection to the database: " + ExceptionUtils.getExceptionTypeOrMessage(e) + "\nThe retrying was unsuccessful.\n\n" + LogUtils.getStackTrace(e) + "\n" + (new OSStackTrace(true)).toString();
                        
                        EventLogger.writeError(message);
                        
                        // Since we already retried it connectionCreationMaxRetries rethrow the exception occurred
                        if (e instanceof SQLException)
                            throw (SQLException)e;
                        if (e instanceof RuntimeException)
                            throw (RuntimeException)e;
                        return WrappedException.wrapExceptionIfNeeded(e);
                    }
                    else if (retryNumber == 1)
                    {
                        message = "Error opening connection to the database: " + ExceptionUtils.getExceptionTypeOrMessage(e) + "\nRetrying...\n\n" + LogUtils.getStackTrace(e) + "\n" + (new OSStackTrace(true)).toString();
                        
                        EventLogger.writeWarning(message);
                    }
                    else if (retryNumber == TransactionServiceConstants.CONNECTION_POOL_CLEANUP_RETRIES)
                    {
                        
                        // We need to clean the connection pools (#26972)
                        releasePooledConnections(ExceptionUtils.getExceptionTypeOrMessage(e));
                    }
                }
            }
        }
        
        return conn;
    }
    
    /**
     *	Checks if an exception thrown while trying to connect to the database is non-transient. If so, no retry is attempted.
     *	@param	exception	The exception to test.
     *	@return	True if it the exception is non-transient, False otherwise.
     */
    protected boolean isNonTransientConnectionException(Exception exception)
    {
        return exception instanceof java.sql.SQLNonTransientConnectionException;
    }
    
    
    /**
	 *	Checks if it is possible to establish a connection.
	 *	@param	errorMessage	Error message that occurred during the test connection.
	 *	@return	True if it was established a connection successfully, False otherwise.
	 */
    public boolean testConnection(RefParmHolder<String> errorMessage) throws SQLException {
        Connection conn = null;
        errorMessage.setVal("" );
        try {
            conn = createConnection(0);
            // Try just one time
        }catch (Exception exceptionToHandle) {
            exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
            
            {
                Exception e = (Exception)exceptionToHandle;
                errorMessage.setVal(ExceptionUtils.getExceptionTypeOrMessage(e) );
                EventLogger.writeError("Error testing connection to the database: " + ExceptionUtils.getExceptionTypeOrMessage(e) + "\n\n" + LogUtils.getStackTrace(e) + "\n" + (new OSStackTrace(true)));
                
                return false;
            }
        }
         finally{
            if (conn != null)
            {
                ConnectionUtils.closeConnection(conn);
            }
        }
        return true;
    }
    
    private final Connection getConnection() throws SQLException {
        Connection conn = null;
        try {
            conn = getConnectionFromDriver();
            /* conn.Open */;
            return conn;
        }catch (Exception exceptionToHandle) {
            exceptionToHandle = WrappedException.unwrapExceptionIfNeeded(exceptionToHandle);
            
            {
                Exception e = (Exception)exceptionToHandle;
                if (conn != null)
                {
                    ConnectionUtils.closeConnection(conn);
                }
                if (e instanceof SQLException)
                    throw (SQLException)e;
                if (e instanceof RuntimeException)
                    throw (RuntimeException)e;
                return WrappedException.wrapExceptionIfNeeded(e);
            }
        }
    }
    
    /**
	 *	Returns a new transaction for the connection provided. This implementation creates a new transaction with the IsolationLevel of the current service.
	 *	@param	conn	Connection where the transaction will be created.
	 *	@return	A transaction using the connection provided.
	 */
    public ADOTransaction createTransaction(Connection conn) throws SQLException {
        ADOTransaction transaction;
        
        // #121301: I know this code looks odd, but according to http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=384544
        //  we should use KeepAlive like they do in SqlTransaction.BeginTransaction() to keep transactions from losing connections...
        try {
            transaction = new ADOTransaction(conn, getIsolationLevel());
            
            return transaction;
        } finally{
        }
    }
    
    /**
	 *	Releases all connections in the connection pool. This implementation releases all connections in the connection pool and logs a warning with the reason.
	 *	@param	reason	Reason why the connections will be released.
	 */
    public void releasePooledConnections(String reason) {
        if (!StringUtilities.isEmpty(reason))
        {
            EventLogger.writeWarning("Cleaning the connection pools because: " + reason + ".\n\n" + (new OSStackTrace(true)).toString());
        }
        
        // #54508 stupid .Net bug            
        releaseAllPooledConnections();
    }
    
    /**
     *	Checks if the connection is closed.
     *	@param	connection	A database connection.
     *	@return	True if the connection is already closed, False otherwise.
     */
    public boolean isClosed(Connection connection) throws SQLException
    {
        return (ConnectionUtils.getConnectionState(connection) == ConnectionState.Closed);
    }
    
    
    /**
	 *	Closes the provided database transaction. This implementation safely closes a transaction. If the transaction or its connection are Null it does nothing.
	 *	@param	tran	Transaction to be closed.
	 */
    public void closeTransaction(ADOTransaction tran) {
        if (tran != null)
        {
            if (tran.getConnection() != null)
            {
                try {
                    tran.returnConnectionToPool();
                    }catch (Exception exceptionToHandle) {
                
            }
        }
    }
}
}
