/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.platform.ddlservice;

import java.text.*;
import java.util.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.databaseobjects.*;
import outsystems.hubedition.extensibility.data.platform.*;
import outsystems.hubedition.extensibility.data.platform.databaseobjects.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import java.math.BigDecimal;
import outsystems.hubedition.extensibility.data.databaseobjects.ITableSourceForeignKeyInfo;
import outsystems.hubedition.extensibility.data.databaseobjects.ITableSourceInfo;
import outsystems.hubedition.extensibility.data.DBDataType;
import outsystems.hubedition.extensibility.data.platform.databaseobjects.IPlatformTableSourceColumnInfo;
import outsystems.hubedition.extensibility.data.platform.databaseobjects.IPlatformTableSourceEventTriggerInfo;
import outsystems.hubedition.extensibility.data.platform.databaseobjects.IPlatformTableSourceIndexInfo;


public interface IDDLService
{
    
    public String getDefaultValue(DBDataType type);
    
    /**
	 *	Returns true if the existingColumn can be converted in the database, (via one of the AlterColumn* operations) to become equivalent to the newColumn. If the column cannot be converted, an errorMessage is also returned.
	 *	@param	existingColumn	Existing column, inspected from the database model
	 *	@param	newColumn	New column, inspected from the application model
	 *	@param	errorMessage	Reason
	 *	@return	True if an alter column operation can be performed, false otherwise
	 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
	 */
    public boolean canAlterColumn(IPlatformTableSourceColumnInfo existingColumn, IPlatformTableSourceColumnInfo newColumn, RefParmHolder<String> errorMessage) throws java.sql.SQLException;
    
    /**
	 *	Returns true if the newColumn can be created in the database, If the column cannot be created, an errorMessage is also returned.
	 *	@param	newColumn	New column, inspected from the application model
	 *	@param	errorMessage	Reason
	 *	@return	True if a create column operation can be performed, false otherwise
	 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
	 */
    public boolean canCreateColumn(IPlatformTableSourceColumnInfo newColumn, RefParmHolder<String> errorMessage) throws java.sql.SQLException;
    
    /**
	 *	Returns true if the newTable can be created in the database, If the table cannot be created, an errorMessage is also returned.
	 *	@param	newTable	New table, inspected from the application model
	 *	@param	columns	Columns, inspected from the application model
	 *	@param	errorMessage	Reason
	 *	@return	True if a create table operation can be performed, false otherwise
	 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
	 */
    public boolean canCreateTable(ITableSourceInfo newTable, ColumnDetails[] columns, RefParmHolder<String> errorMessage) throws java.sql.SQLException;
    
    /**
	 *	This method generates the SQL to create a new table.
	 *	@param	newTable	Info about the table to create.
	 *	@param	columns	The columns information for the table to create along with the default values.      Note that some of them may be primary keys, as indicated on the IsPrimaryKey property.      This will lead to the creation of Primary Key Constraints.      Also note that a column could be an autonumber column, there&#39;s no need to call the AlterColumnChangeAutoNumber after.
	 *	@return	SQL statements to create the table.
	 */
    public Iterable<String> createTable(ITableSourceInfo newTable, ColumnDetails ... columns);
    
    /**
	 *	This method generates the SQL to drop a table previously obtained through the IIntrospectionService API.
	 *	@param	existingTable	Info about the table to drop.
	 *	@return	SQL statements to drop the table.
	 */
    public Iterable<String> dropTable(ITableSourceInfo existingTable);
    
    /**
	 *	This method generates the SQL to create a new index.
	 *	@param	newIndex	Info about the index to create.
	 *	@return	SQL statements to create the index.
	 */
    public Iterable<String> createIndex(IPlatformTableSourceIndexInfo newIndex);
    
    /**
	 *	This method generates the SQL to drop an index previously obtained through the IIntrospectionService API.
	 *	@param	existingIndex	Info about the index to drop.
	 *	@return	SQL statements to drop the index.
	 */
    public Iterable<String> dropIndex(IPlatformTableSourceIndexInfo existingIndex);
    
    /**
	 *	This method generates the SQL to create a new foreign key.
	 *	@param	newForeignKey	Info about the foreign key to create.
	 *	@return	SQL statements to create the foreign key.
	 */
    public Iterable<String> createForeignKey(ITableSourceForeignKeyInfo newForeignKey);
    
    /**
	 *	This method generates the SQL to drop a foreign key previously obtained through the IIntrospectionService API.
	 *	@param	existingForeignKey	Info about the foreign key to drop.
	 *	@return	SQL statements to drop the foreign key.
	 */
    public Iterable<String> dropForeignKey(ITableSourceForeignKeyInfo existingForeignKey);
    
    /**
	 *	This method generates the SQL to create an after insert or update event trigger. For each affected row in the trigger table, it validates if it needs to fire an event by crossing the values in the  triggerTableEventColumns with the contents of the table eventTable. For each event that must be fired the trigger must insert an entry in the table eventQueueTable.
	 *	@param	newTrigger	Info about the trigger to create.
	 *	@param	triggerTablePrimaryKeyColumn	Primary key column of the table associated with the trigger.
	 *	@param	triggerTableEventColumns	Columns of the table associated with the trigger that fire events.
	 *	@param	triggerTableForeignKeys	Foreign keys of the table associated with the trigger.
	 *	@param	eventTable	Table source that stores the events for the table associated with the trigger.
	 *	@param	eventQueueTable	Table source that stores the events to be fired by the platform.
	 *	@return	SQL statements to create the event trigger.
	 */
    public Iterable<String> createEventTrigger(IPlatformTableSourceEventTriggerInfo newTrigger, IPlatformTableSourceColumnInfo triggerTablePrimaryKeyColumn, Iterable<IPlatformTableSourceColumnInfo> triggerTableEventColumns, Iterable<ITableSourceForeignKeyInfo> triggerTableForeignKeys, ITableSourceInfo eventTable, ITableSourceInfo eventQueueTable);
    
    /**
	 *	This method generates the SQL to drop a trigger previously obtained through the IIntrospectionService API.
	 *	@param	existingTrigger	Info about the trigger to drop.
	 *	@return	SQL statements to drop the trigger.
	 */
    public Iterable<String> dropEventTrigger(IPlatformTableSourceEventTriggerInfo existingTrigger);
    
    /**
	 *	This method generates the SQL to create a new column.
	 *	@param	newColumn	Info about the column to create.
	 *	@param	defaultValue	Column default value. It could be empty.
	 *	@return	SQL statements to create the column.
	 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
	 */
    public Iterable<String> createColumn(IPlatformTableSourceColumnInfo newColumn, String defaultValue) throws java.sql.SQLException;
    
    /**
	 *	This method generates the SQL to drop a column previously obtained through the IIntrospectionService API.
	 *	@param	existingColumn	Info about the column to drop.
	 *	@return	SQL statements to drop the column.
	 */
    public Iterable<String> dropColumn(IPlatformTableSourceColumnInfo existingColumn);
    
    /**
	 *	This method generates the SQL to change a column previously obtained through the IIntrospectionService API.
	 *	@param	existingColumn	Info about the column to change.
	 *	@param	newColumn	New Info about the column.
	 *	@param	defaultValue	The new column default value. It could be null.
	 *	@return	SQL statements to change the column.
	 *	@throws	java.sql.SQLException	If an error occurs while accessing the database.
	 */
    public Iterable<String> alterColumn(IPlatformTableSourceColumnInfo existingColumn, IPlatformTableSourceColumnInfo newColumn, String defaultValue) throws java.sql.SQLException;
    
    /**
	 *	This method generates the SQL to create a new view. If already exists a view with the same name it should be replaced by the new one.
	 *	@param	newView	Info about the view we want to create.
	 *	@param	viewSQL	SQL query that defines the view contents.
	 *	@param	withCheckOption	true if the INSERT and UPDATE operations performed over the view should be constrained only to the rows referenced by the view
	 *	@return	SQL statements to create the view.
	 */
    public Iterable<String> createOrReplaceView(ITableSourceInfo newView, String viewSQL, boolean withCheckOption);
    
    /**
	 *	This method generates the SQL to grant permissions on a table source to a user.
	 *	@param	existingTableSource	Info about the table or view which we want to grant permissions on.
	 *	@param	username	User to grant permissions.
	 *	@param	permissions	Permissions to grant to the user.
	 *	@return	SQL statements to grant permissions.
	 */
    public Iterable<String> grantPermissions(ITableSourceInfo existingTableSource, String username, EnumSet<Permissions> permissions);
    
    
    /**
	 *	This method generates the SQL to enable all the triggers for an existing table source.
	 *	@param	existingTableSource	Info about the table source which we want to enable the triggers.
	 *	@return	SQL statements to enable the triggers.
	 */
    public Iterable<String> enableTriggers(ITableSourceInfo existingTableSource);
    
    /**
	 *	This method generates the SQL to disable all the triggers for an existing table source.
	 *	@param	existingTableSource	Info about the table source which we want to disable the triggers.
	 *	@return	SQL statements to disable the triggers.
	 */
    public Iterable<String> disableTriggers(ITableSourceInfo existingTableSource);
    
    /**
	 *	This method generates the SQL to enable the auto-number behavior for an existing table source.
	 *	@param	existingTableSource	Info about the table source which we want to enable the auto-number.
	 *	@return	SQL statements to enable the auto-number.
	 */
    public Iterable<String> enableAutoNumber(ITableSourceInfo existingTableSource);
    
    /**
	 *	This method generates the SQL to disable the auto-number behavior for an existing table source.
	 *	@param	existingTableSource	Info about the table source which we want to disable the auto-number.
	 *	@return	SQL statements to disable the auto-number.
	 */
    public Iterable<String> disableAutoNumber(ITableSourceInfo existingTableSource);
}
