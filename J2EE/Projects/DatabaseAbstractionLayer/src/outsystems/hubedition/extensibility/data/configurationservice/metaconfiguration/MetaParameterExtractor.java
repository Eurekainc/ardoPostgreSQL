/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.configurationservice.metaconfiguration;

import java.lang.reflect.*;
import java.net.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.*;
import linqbridge.linq.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.configurationservice.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.util.Map;
import linqbridge.linq.LinqMethods;
import outsystems.hubedition.extensibility.data.configurationservice.ConfigurationParameter;
import outsystems.hubedition.extensibility.data.configurationservice.UserDefinedConfigurationParameter;




public class MetaParameterExtractor {
    public static final TypeInformation<MetaParameterExtractor> TypeInfo = TypeInformation.get(MetaParameterExtractor.class);
    
    
    public static enum MetaParamType implements IEnum {
        Parameter,
        UserDefinedParameter,
        UserChosenOptionParameter;
        
        public static final TypeInformation<MetaParamType> TypeInfo = TypeInformation.get(MetaParamType.class);
        public int getIntValue() {
            return ordinal();
        }
        
        public static String[] names() {
            return EnumUtils.getNames(values());
        }
        
        public static MetaParamType getDefaultValue() {
            return Parameter;
        }
        
        private static Map<Integer, MetaParamType> intToEnum;
        private static Map<Integer, MetaParamType> getIntToEnum() {
            if (intToEnum == null) {
                intToEnum = EnumUtils.getIntToEnumValueMap(values());
            }
            return intToEnum;
        }
        
        private static Map<String, MetaParamType> lowerCaseNameToEnum;
        private static Map<String, MetaParamType> getLowerCaseNameToEnum() {
            if (lowerCaseNameToEnum == null) {
                lowerCaseNameToEnum = EnumUtils.getNameToEnumValueMap(values(), /*lowerCase*/true);
            }
            return lowerCaseNameToEnum;
        }
        
        private static Map<String, MetaParamType> nameToEnum;
        private static Map<String, MetaParamType> getNameToEnum() {
            if (nameToEnum == null) {
                nameToEnum = EnumUtils.getNameToEnumValueMap(values(), /*lowerCase*/false);
            }
            return nameToEnum;
        }
        
        public static MetaParamType valueOf(int value) {
            MetaParamType result = getIntToEnum().get(value);
            if (result == null) {
                throw new IllegalArgumentException("No enum const class MetaParamType with int value " + value);
            }
            return result;
        }
        
        
        public static MetaParamType valueOf(String value, boolean ignoreCase) {
            if (!ignoreCase) {
                return valueOf(value);
            }
            MetaParamType result = getLowerCaseNameToEnum().get(value.toLowerCase());
            if (result == null) {
                throw new IllegalArgumentException("No enum const class MetaParamType." + value);
            }
            return result;
        }
        
        
        public static boolean isDefined(String value) {
            return getNameToEnum().containsKey(value);
        }
        
        public static boolean isDefined(int value) {
            return getIntToEnum().containsKey(value);
        }
    }
    
    
    public static class MetaParam {
        private MetaParamType _type;
        private String _propName;
        private Method _getter;
        private Method _setter;
        private boolean _encrypt;
        private boolean _persist;
        private Method _visibilityChecker;
        private UserDefinedConfigurationParameter _userConfigurationParameter;
        private HashMap<String, Map.Entry<String, String>> _helpInfo;
        public static final TypeInformation<MetaParam> TypeInfo = TypeInformation.get(MetaParam.class);
        
        
        public final MetaParamType getType()
        {
            return _type;
        }
        
        
        public final void setType(MetaParamType value)
        {
            _type = value;
        }
        
        public final String getPropName()
        {
            return _propName;
        }
        
        
        public final void setPropName(String value)
        {
            _propName = value;
        }
        
        public final Method getGetter()
        {
            return _getter;
        }
        
        
        public final void setGetter(Method value)
        {
            _getter = value;
        }
        
        public final Method getSetter()
        {
            return _setter;
        }
        
        
        public final void setSetter(Method value)
        {
            _setter = value;
        }
        
        public final boolean isEncrypt()
        {
            return _encrypt;
        }
        
        
        public final void setEncrypt(boolean value)
        {
            _encrypt = value;
        }
        
        public final boolean isPersist()
        {
            return _persist;
        }
        
        
        public final void setPersist(boolean value)
        {
            _persist = value;
        }
        
        public final Method getvisibilityChecker()
        {
            return _visibilityChecker;
        }
        
        
        public final void setvisibilityChecker(Method value)
        {
            _visibilityChecker = value;
        }
        
        public final UserDefinedConfigurationParameter getUserConfigurationParameter()
        {
            return _userConfigurationParameter;
        }
        
        
        public final void setUserConfigurationParameter(UserDefinedConfigurationParameter value)
        {
            _userConfigurationParameter = value;
        }
        
        public final HashMap<String, Map.Entry<String, String>> getHelpInfo()
        {
            return _helpInfo;
        }
        
        
        public final void setHelpInfo(HashMap<String, Map.Entry<String, String>> value)
        {
            _helpInfo = value;
        }
        
        
        public final IParameter toParameter(Object configuraiton) {
            switch (getType())
            {
                case Parameter : 
                    return new Parameter(getPropName(), getGetter(), getSetter(), isEncrypt(), isPersist(), configuraiton);
                case UserDefinedParameter : 
                    return new UserDefinedParameter(getPropName(), getGetter(), getSetter(), configuraiton, isEncrypt(), isPersist(), getvisibilityChecker(), getUserConfigurationParameter());
                default:
                    throw new IllegalStateException("Unexpected parameter type" + getType());
            }
        }
    }
    
    
    
    private List<MetaParam> parameters;
    
    public MetaParameterExtractor(Class<?> configurationType){
        this.parameters = findParameters(configurationType);
    }
    
    
    private final List<MetaParam> findParameters(Class<?> type) {
        Map<String, MetaParam> results = new HashMap<String, MetaParam>();
        for( Class<?> t = type; t != null; t = t.getSuperclass())
        {
            for (Method prop : t.getMethods()) {
                java.lang.annotation.Annotation param = getConfigurationParameter(prop);
                if (param != null && !results.containsKey(prop.getName()))
                {
                    CollectionUtils.addToMap(results,prop.getName(),getParameterToAdd(type, param, prop));
                }
            }
        }
        return LinqMethods.toList(results.values());
    }
    
    
    private static java.lang.annotation.Annotation getConfigurationParameter(Method prop)
    {
        
        boolean looksLikeBooleanGetter = !prop.getReturnType().equals(Void.TYPE)
                                            && prop.getName().startsWith("is")
                                            && prop.getReturnType().equals(Boolean.TYPE);
        
        boolean looksLikeGetter = !prop.getReturnType().equals(Void.TYPE)
        							&& prop.getName().startsWith("get");
        
        Annotation attr = prop.getAnnotation(UserDefinedConfigurationParameter.class);	
        
        if (attr == null) {
            attr = prop.getAnnotation(ConfigurationParameter.class);
        }
        		
        return (attr != null && (looksLikeGetter || looksLikeBooleanGetter)) ? attr : null;
        
    }
    
    
    
    
    
    private final MetaParam getParameterToAdd(Class<?> type, java.lang.annotation.Annotation param, Method prop) {
        String propName = prop.getReturnType().equals(Boolean.TYPE) ? prop.getName().substring("is".length()) : prop.getName().substring("get".length());
        Method getter = prop;
        Method setter = ClassUtils.getMethod(prop.getDeclaringClass(), "set" + propName);
        
        UserDefinedConfigurationParameter userDefinedConfigParam = ClassUtils.safeCast(param, UserDefinedConfigurationParameter.class);
        if (userDefinedConfigParam != null)
        {
            Method visibilityChecker = null;
            if (!StringUtils.isNullOrEmpty(userDefinedConfigParam.visibilityChecker()))
            {
                visibilityChecker = ClassUtils.getMethod(type, userDefinedConfigParam.visibilityChecker() );
            }
            return new IObjectInitializer<MetaParam>() {
                    public MetaParam setup(MetaParam obj, MetaParamType type, String propName, Method getter, Method setter, boolean encrypt, boolean persist, Method visibilityChecker, UserDefinedConfigurationParameter userConfigurationParameter) {
                        obj.setType(type);
                        obj.setPropName(propName);
                        obj.setGetter(getter);
                        obj.setSetter(setter);
                        obj.setEncrypt(encrypt);
                        obj.setPersist(persist);
                        obj.setvisibilityChecker(visibilityChecker);
                        obj.setUserConfigurationParameter(userConfigurationParameter);
                        return obj;
                    }
                }.setup(new MetaParam(), MetaParamType.UserDefinedParameter, propName, getter, setter, userDefinedConfigParam.encrypt(), userDefinedConfigParam.persist(), visibilityChecker, userDefinedConfigParam);
        }
        
        ConfigurationParameter configParam = (ConfigurationParameter) param;
        return new IObjectInitializer<MetaParam>() {
                public MetaParam setup(MetaParam obj, MetaParamType type, String propName, Method getter, Method setter, boolean encrypt, boolean persist) {
                    obj.setType(type);
                    obj.setPropName(propName);
                    obj.setGetter(getter);
                    obj.setSetter(setter);
                    obj.setEncrypt(encrypt);
                    obj.setPersist(persist);
                    return obj;
                }
            }.setup(new MetaParam(), MetaParamType.Parameter, propName, getter, setter, configParam.encrypt(), configParam.persist());
    }
    
    
    public final List<IParameter> toParameters(final Object configuration) {
        return LinqMethods.toList(LinqMethods.select(parameters, (MetaParam p) -> {
            return p.toParameter(configuration);
        }));
    }
    
}
