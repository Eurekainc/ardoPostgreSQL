/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package outsystems.hubedition.extensibility.data.platform.configuration;

import java.io.*;
import java.nio.*;
import java.nio.charset.*;
import java.text.*;
import java.util.*;
import java.util.regex.*;
import linqbridge.linq.*;
import outsystems.hubedition.extensibility.data.*;
import outsystems.hubedition.extensibility.data.platform.*;
import outsystems.hubedition.util.*;
import outsystems.hubedition.util.delegates.*;
import outsystems.runtimecommon.*;
import java.math.BigDecimal;
import java.util.Map;
import linqbridge.linq.LinqMethods;
import outsystems.runtimecommon.CollectionsExtensions;


public abstract class BasePlatformConfigurationManager extends BaseConfigurationManager implements IPlatformConfigurationManager {
    public static final TypeInformation<BasePlatformConfigurationManager> TypeInfo = TypeInformation.get(BasePlatformConfigurationManager.class);
    protected IPlatformDatabaseConfiguration uiConfiguration;
    
    public BasePlatformConfigurationManager(IPlatformDatabaseConfiguration uiConfiguration){
        this.uiConfiguration = uiConfiguration;
    }
    
    public abstract boolean isRecommendDatabaseBackup();
    
    public abstract void pre_CreateOrUpgradePlatform();
    
    public boolean testAdminConnection(RefParmHolder<String> friendlyMessage, Source source) throws java.sql.SQLException {
        boolean sucess = testConnection(uiConfiguration.runtimeDatabaseConfiguration(source, User.Admin),
            friendlyMessage);
        if (!sucess)
        {
            RefParmHolder<String> newFriendlyMessage = new RefParmHolder<String>();
            String upperCaseUser = ((BasePlatformDatabaseConfiguration) uiConfiguration).getAdminUser();
            ((BasePlatformDatabaseConfiguration) uiConfiguration).setAdminUser( upperCaseUser.toUpperCase(java.util.Locale.ROOT) );
            sucess = testConnection(uiConfiguration.runtimeDatabaseConfiguration(source, User.Admin),
                newFriendlyMessage);
            if (!sucess)
            {
                ((BasePlatformDatabaseConfiguration) uiConfiguration).setAdminUser( upperCaseUser );
            }
            else
            {
                friendlyMessage.setVal(newFriendlyMessage.getVal() );
            }
        }
        return sucess;
    }
    
    public boolean testRuntimeConnection(RefParmHolder<String> friendlyMessage, Source source) throws java.sql.SQLException {
        boolean sucess = testConnection(uiConfiguration.runtimeDatabaseConfiguration(source, User.Runtime),
            friendlyMessage);
        if (!sucess)
        {
            RefParmHolder<String> newFriendlyMessage = new RefParmHolder<String>();
            String upperCaseUser = ((BasePlatformDatabaseConfiguration) uiConfiguration).getRuntimeUser();
            ((BasePlatformDatabaseConfiguration) uiConfiguration).setRuntimeUser( upperCaseUser.toUpperCase(java.util.Locale.ROOT) );
            sucess = testConnection(uiConfiguration.runtimeDatabaseConfiguration(source, User.Runtime),
                newFriendlyMessage);
            if (!sucess)
            {
                ((BasePlatformDatabaseConfiguration) uiConfiguration).setRuntimeUser( upperCaseUser );
            }
            else
            {
                friendlyMessage.setVal(newFriendlyMessage.getVal() );
            }
        }
        return sucess;
    }
    
    public boolean testLogConnection(RefParmHolder<String> friendlyMessage, Source source) throws java.sql.SQLException {
        boolean sucess = testConnection(uiConfiguration.runtimeDatabaseConfiguration(source, User.Log),
            friendlyMessage);
        if (!sucess)
        {
            RefParmHolder<String> newFriendlyMessage = new RefParmHolder<String>();
            String upperCaseUser = ((BasePlatformDatabaseConfiguration) uiConfiguration).getLogUser();
            ((BasePlatformDatabaseConfiguration) uiConfiguration).setLogUser( upperCaseUser.toUpperCase(java.util.Locale.ROOT) );
            sucess = testConnection(uiConfiguration.runtimeDatabaseConfiguration(source, User.Log),
                newFriendlyMessage);
            if (!sucess)
            {
                ((BasePlatformDatabaseConfiguration) uiConfiguration).setLogUser( upperCaseUser );
            }
            else
            {
                friendlyMessage.setVal(newFriendlyMessage.getVal() );
            }
        }
        return sucess;
    }
    
    
    public abstract FileStream getStreamForScriptFile() throws FileNotFoundException, java.net.URISyntaxException;
    
    public abstract String processStatement(String statement);
    
    public Version getUpgradeVersion() throws Exception {
        String script = readScriptFile(getStreamForScriptFile());
        String version = LinqMethods.first(Block.TypeInfo, sliceModelScript(script, null), 
    new Func.Func1<Block, Boolean>() {
        protected Boolean executeImpl(Block b) throws Exception
        {
            return b.getConditionTag() == Tag.SCRIPT_VERSION;
        }
    }).getValue();
        return new Version(version);
    }
    
    public final Iterable<Block> platformStatements(Version currentModelVersion) throws Exception {
        return new Iterable<Block>() {
            Version currentModelVersion;
            
            public Iterable<Block> setup(Version currentModelVersion) {
                this.currentModelVersion = currentModelVersion;
                return this;
            }
            public Iterator<Block> iterator() {
                return new Yielder<Block>() {
                    String script;
                    java.util.Iterator<Block> blockIter;
                    Block block;
                    
                    int i;
                    String statement;
                    java.util.Iterator<Block> blockIter1;
                    Block block1;
                    Version currentModelVersion;
                    
                    public Yielder<Block> setup(Version currentModelVersion) {
                        this.currentModelVersion = currentModelVersion;
                        return this;
                    }
                    
                    protected boolean advance() throws Exception
                    {
                        switch (currentStatement) {
                            case BEGIN:
                                script = readScriptFile(getStreamForScriptFile());
                                blockIter = (sliceModelScript(script, currentModelVersion)).iterator();
                            case STATEMENT_1:
                                try {
                                    while (skipLoopCondition || (blockIter.hasNext())) {
                                        if (!skipLoopCondition) {
                                            block = blockIter.next();
                                        }
                                        switch (currentStatement) {
                                            default:
                                                for( int i = 0; i < block.getStatements().size(); i++)
                                                {
                                                    statement = processStatement(block.getStatements().get(i));
                                                    if (!CollectionsExtensions.isNullOrEmpty(statement))
                                                    {
                                                        block.getStatements().set(i, statement);
                                                    }
                                                }
                                                return yieldReturn(block, STATEMENT_1, SKIP_LOOP_CONDITION);
                                            case STATEMENT_1:
                                                resetControlVariables();
                                        }
                                    }
                                } finally {
                                    if (!isReturningThroughYieldReturn()) {
                                        CollectionUtils.dispose(blockIter);
                                    }
                                }
                                
                                blockIter1 = (extraPlatformStatements(currentModelVersion)).iterator();
                            case STATEMENT_2:
                                try {
                                    while (skipLoopCondition || (blockIter1.hasNext())) {
                                        if (!skipLoopCondition) {
                                            block1 = blockIter1.next();
                                        }
                                        switch (currentStatement) {
                                            default:
                                                return yieldReturn(block1, STATEMENT_2, SKIP_LOOP_CONDITION);
                                            case STATEMENT_2:
                                                resetControlVariables();
                                        }
                                    }
                                } finally {
                                    if (!isReturningThroughYieldReturn()) {
                                        CollectionUtils.dispose(blockIter1);
                                    }
                                }
                        }
                        return yieldBreak();
                    }
                    
                    public void dispose() {
                        try {
                            if (blockIter != null) {
                                CollectionUtils.dispose(blockIter);
                                blockIter = null;
                            }
                            if (blockIter1 != null) {
                                CollectionUtils.dispose(blockIter1);
                                blockIter1 = null;
                            }
                            }
                        catch (Exception e)
                        {
                            WrappedException.wrapExceptionIfNeeded(e);
                        }
                        
                    }
                }.setup(currentModelVersion);
            }
        }.setup(currentModelVersion);
    }
    
    public Iterable<Block> extraPlatformStatements(Version currentModelVersion) {
        return new Iterable<Block>() {
            Version currentModelVersion;
            
            public Iterable<Block> setup(Version currentModelVersion) {
                this.currentModelVersion = currentModelVersion;
                return this;
            }
            public Iterator<Block> iterator() {
                return new Yielder<Block>() {
                    Version currentModelVersion;
                    
                    public Yielder<Block> setup(Version currentModelVersion) {
                        this.currentModelVersion = currentModelVersion;
                        return this;
                    }
                    
                    protected boolean advance() throws Exception
                    {
                        return yieldBreak();
                    }
                }.setup(currentModelVersion);
            }
        }.setup(currentModelVersion);
    }
    
    private static final Pattern LineTagRegex = Pattern.compile("--[\\t ]*%(.+)%[\\t ]*(?:=[\\t ]*\\\"(.*)\\\")?", 0);
    
    protected final String lineExtractTag(String sourceLine, int sourceLineNum, RefParmHolder<String> tagName) throws Exception {
        // match: '-- %TAG_NAME% = "Tag Content"'
        tagName.setVal("" );
        if (sourceLine.startsWith("--"))
        {
            Match match = RegexUtils.match(LineTagRegex, sourceLine);
            if (RegexUtils.isSuccess(match))
            {
                tagName.setVal(match.group(1).getValue() );
                return match.group(2).getValue();
            }
            // some developer error, writing the tag?
            // else, some errors could silently go unnoticed...
            if (StringUtils.trimStart(sourceLine, '\t', ' ').startsWith("--%"))
            {
                throw new Exception("Could not parse tag. Line no: " + sourceLineNum + " Line content: '" + sourceLine + "'");
            }
        }
        return "";
        // not a tag line
    }
    
    //Some tags are statements and not blocks
    protected boolean isStatement(String tag, String tagValue) {
        if (StringUtils.equals(tag, ""))
        {
            return true;
        }
        Tag tagEnum = Tag.valueOf(tag);
        if (tagEnum == Tag.DROP_COLUMN || tagEnum == Tag.SPECIFIC_UPGRADE)
        {
            return true;
        }
        return false;
    }
    
    private final boolean lineHasTag(String sourceLine, RefParmHolder<String> tagName) throws Exception {
        lineExtractTag(sourceLine, 0,
            tagName);
        return !StringUtils.equals(tagName.getVal(), "");
    }
    
    private final String readStatement(StringReader reader, RefParmHolderInteger sourceLineNum) throws Exception {
        StringBuilder sb = null;
        String line;
        while (!StringUtils.equals((line = StreamUtils.readLine(reader)), null))
        {
            if (sb == null)
            {
                sb = new StringBuilder();
            }
            
            RefParmHolder<String> tag = new RefParmHolder<String>();
            sourceLineNum.valPostIncr();
            
            if (lineHasTag(line,
                tag))
            {
                sb.append(line).append(StringUtils.newLine);
                break;
            }
            
            if ((StringUtils.equals(line.trim().toUpperCase(), getStatementSeparator())))
            {
                break;
            }
            
            if (!StringUtils.equals(line.trim(), "") && !line.trim().startsWith("--"))
            {
                sb.append(line).append(StringUtils.newLine);
            }
        }
        
        return sb != null ? sb.toString() : null;
    }
    
    protected boolean validateStatement(String sourceLine, String tagName) {
        return (!StringUtils.equals(sourceLine, "") && !sourceLine.startsWith("--")) || !StringUtils.equals(tagName, "");
    }
    
    private final Iterable<Block> sliceModelScript(String script, Version sliceVersion) throws Exception {
        return new Iterable<Block>() {
            String script;
            Version sliceVersion;
            
            public Iterable<Block> setup(String script, Version sliceVersion) {
                this.script = script;
                this.sliceVersion = sliceVersion;
                return this;
            }
            public Iterator<Block> iterator() {
                return new Yielder<Block>() {
                    String sourceLine;
                    RefParmHolderInteger sourceLineNum = new RefParmHolderInteger();
                    RefParmHolder<String> tagName = new RefParmHolder<String>();
                    String tagValue;
                    
                    StringReader reader;
                    Block statement;
                    boolean cond1;
                    String script;
                    Version sliceVersion;
                    
                    public Yielder<Block> setup(String script, Version sliceVersion) {
                        this.script = script;
                        this.sliceVersion = sliceVersion;
                        return this;
                    }
                    
                    protected boolean advance() throws Exception
                    {
                        switch (currentStatement) {
                            case BEGIN:
                                ;
                                sourceLineNum = new RefParmHolderInteger();
                                tagName = new RefParmHolder<String>();
                                ;
                                reader = new StringReader(script);
                            default:
                                try 
                                {
                                    switch (currentStatement) {
                                        default:
                                            statement = new Block();
                                            sourceLineNum.setVal(1 );
                                            sourceLine = StreamUtils.readLine(reader);
                                            tagValue = lineExtractTag(sourceLine, sourceLineNum.getVal(),
                                                tagName);
                                            
                                            
                                            if (!StringUtils.equals(tagName.getVal(), Tag.SCRIPT_VERSION.toString()))
                                            {
                                                throw new Exception("Could not get current schema version from script file");
                                            }
                                            
                                            statement.setTagValue(tagName.getVal(), tagValue);
                                            
                                            return yieldReturn(statement, STATEMENT_1);
                                            
                                        case STATEMENT_1:
                                            resetControlVariables();
                                            while (!StringUtils.equals((sourceLine = StreamUtils.readLine(reader)), null))
                                            {
                                                
                                                sourceLineNum.valPostIncr();
                                                tagValue = lineExtractTag(sourceLine, sourceLineNum.getVal(),
                                                    tagName);
                                                
                                                if (StringUtils.equals(tagName.getVal(), Tag.VERSION_UPGRADE.toString()) && (new Version(tagValue).compareTo(sliceVersion) >= 0) || StringUtils.equals(tagName.getVal(), Tag.TOUCH_VERSION.toString()))
                                                {
                                                    statement = new Block();
                                                    statement.setTagValue(tagName.getVal(), tagValue);
                                                    break;
                                                }
                                            }
                                            
                                        case STATEMENT_2:
                                            while (skipLoopCondition || (!StringUtils.equals((sourceLine = readStatement(reader,
    sourceLineNum)), null)))
                                            {
                                                switch (currentStatement) {
                                                    default:
                                                        
                                                        tagValue = lineExtractTag(sourceLine, sourceLineNum.getVal(),
                                                            tagName);
                                                        
                                                        sourceLineNum.valPostIncr();
                                                        cond1 = 
                                                        isStatement(tagName.getVal(), tagValue);
                                                    case STATEMENT_2:
                                                        if (cond1)
                                                        {
                                                            if (validateStatement(sourceLine, tagName.getVal()))
                                                            {
                                                                statement.addStatement(sourceLine);
                                                            }
                                                        }
                                                        else
                                                        {
                                                            switch (currentStatement) {
                                                                default:
                                                                    return yieldReturn(statement, STATEMENT_2, SKIP_LOOP_CONDITION);
                                                                case STATEMENT_2:
                                                                    resetControlVariables();
                                                                    statement = new Block();
                                                                    statement.setTagValue(tagName.getVal(), tagValue);
                                                            }
                                                        }
                                                }
                                            }
                                            
                                            return yieldReturn(statement, STATEMENT_3);
                                        case STATEMENT_3:
                                            resetControlVariables();
                                    }
                                }
                                finally {
                                    if (!isReturningThroughYieldReturn()) {
                                        if (reader!= null) {
                                            reader.close();
                                            reader = null;
                                        }
                                        
                                    }
                                }
                        }
                        return yieldBreak();
                    }
                    
                    public void dispose() {
                        try {
                            if (reader!= null) {
                                reader.close();
                                reader = null;
                            }
                            }
                        catch (Exception e)
                        {
                            WrappedException.wrapExceptionIfNeeded(e);
                        }
                        
                    }
                }.setup(script, sliceVersion);
            }
        }.setup(script, sliceVersion);
    }
}
