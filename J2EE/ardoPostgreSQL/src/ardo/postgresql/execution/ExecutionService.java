/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package ardo.postgresql.execution;

import java.sql.SQLException;
import java.sql.Types;

import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOCommand;
import outsystems.hubedition.databaseabstractionlayer.adoadapters.ADOParameter;
import outsystems.hubedition.extensibility.data.DBDataType;
import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.hubedition.extensibility.data.executionservice.BaseExecutionService;
import outsystems.hubedition.extensibility.data.executionservice.SqlTypes;
import outsystems.hubedition.util.TypeInformation;


/**
 *	Base implementation of a database service that handles the execution of statements made while connected to a database.
 */
public class ExecutionService extends BaseExecutionService {
    public static final TypeInformation<ExecutionService> TypeInfo = TypeInformation.get(ExecutionService.class);
    
    /**
	 *	Initializes a new instance of the ExecutionService class.
	 *	@param	databaseServices	The database services to be used with this execution service.
	 */
    public ExecutionService(IDatabaseServices databaseServices){
        super(databaseServices);
    }
	
	/**
	 *	Gets the prefix used to qualify command parameters (e.g. @)
	 */
    public String getParameterPrefix() {
    	// since jdbc doesnt support named parameters as far as I can tell, this implementation comes from our ADO adapters.
    	// if so, why do I need to fill this in? Isn't the prefix always going to be @ ?
        return "@";
    }
    
    public SqlTypes convertToDbType(DBDataType type, String providerType) {
        switch (type) {
            case TEXT: {
                return SqlTypes.VARCHAR;
            }
            case INTEGER: {
                return SqlTypes.INTEGER;
            }
            case DECIMAL: {
                return SqlTypes.DECIMAL;
            }
            case DATE_TIME: {
                return SqlTypes.TIMESTAMP;
            }
            case DATE: {
                return SqlTypes.DATE;
            }
            case TIME: {
                return SqlTypes.TIME;
            }
            case BOOLEAN: {
                return SqlTypes.BOOLEAN;
            }
            case BINARY_DATA: {
                return SqlTypes.BINARY;
            }
            default: {
                throw new UnsupportedOperationException("Unable to convert " + type.toString() + " to SqlTypes");
            }
        }
    }

    
    /**
	 *	Checks if an exception was raised due to a connection error.
	 *	@param	e	Exception raised.
	 *	@return	True if the exception was due to a connection problem, False otherwise.
	 */
	@Override
	public boolean isConnectionException(SQLException arg0) {
		return false;
	}
}
