/* 
 This source code (the "Generated Software") is generated by the OutSystems Platform 
 and is licensed by OutSystems (http://www.outsystems.com) to You solely for testing and evaluation 
 purposes, unless You and OutSystems have executed a specific agreement covering the use terms and 
 conditions of the Generated Software, in which case such agreement shall apply. 
*/

package ardo.postgresql.introspection;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.LinkedList;
import java.util.List;

import outsystems.hubedition.extensibility.data.IDatabaseServices;
import outsystems.hubedition.extensibility.data.databaseobjects.IDatabaseInfo;
import outsystems.hubedition.extensibility.data.databaseobjects.ITableSourceColumnInfo;
import outsystems.hubedition.extensibility.data.databaseobjects.ITableSourceForeignKeyInfo;
import outsystems.hubedition.extensibility.data.databaseobjects.ITableSourceInfo;
import outsystems.hubedition.extensibility.data.introspectionservice.BaseIntrospectionService;
import outsystems.hubedition.extensibility.data.introspectionservice.IsTableSourceToIgnore;
import outsystems.hubedition.util.TypeInformation;

/**
 *	Inspects a database server to retrieve information about its data model.
 */
public class IntrospectionService extends BaseIntrospectionService {
    public static final TypeInformation<IntrospectionService> TypeInfo = TypeInformation.get(IntrospectionService.class);
    
    /**
	 *	Initializes a new instance of the IntrospectionService class.
	 *	@param	databaseServices	The database services.
	 */
    public IntrospectionService(IDatabaseServices databaseServices){
        super(databaseServices);
    }
    
    /**
	 *	Returns the list of databases that can be accessed from the current configuration. A database is a logical group of data objects (e.g. tables, views) that the plugin maps to a db-specific concept (e.g. SQL Server catalog or Oracle schema).
	 *	@return	List of available databases in the given server
	 *	@throws	SQLException	if an error occurs while accessing the database
	 */
    public Iterable<IDatabaseInfo> listDatabases() throws SQLException {
        List<IDatabaseInfo> result = new LinkedList<IDatabaseInfo>();
        
	    Connection conn = getConnection();
	    Statement stmt = conn.createStatement();
	    
        try {
        	
		    ResultSet res = stmt.executeQuery("SELECT schema_name FROM information_schema.schemata");
		    
		    boolean added_public = false;
		    while (res.next()) {
		    	String schema = res.getString(1);
		    	result.add(new DatabaseInfo(getDatabaseServices(), schema));
		    	if (schema.equals("public"))
		    		added_public = true;
		    }
		    if (!added_public)
		    	result.add(new DatabaseInfo(getDatabaseServices(), "public"));
		    
        } finally {
        	stmt.close();
        	conn.close();
        }
        
        return result;
    }
    
    /**
	 *	Returns a list of table sources (e.g. tables, views) that belong to a given database.  The returned table sources must have different display names.
	 *	@param	database	Database from which we want to fetch the list of tables
	 *	@param	isTableSourceToIgnore	The delegate to call to see if the table source should be ignored and excluded from the returned list
	 *	@return	List of available table sources in the given database
	 *	@throws	SQLException	if an error occurs while accessing the database
	 */
    public Iterable<ITableSourceInfo> listTableSources(IDatabaseInfo database, IsTableSourceToIgnore isTableSourceToIgnore) throws SQLException {
        List<ITableSourceInfo> result = new LinkedList<ITableSourceInfo>();
        
    	Connection conn = getConnection();
    	try {
    		PreparedStatement stmt = conn.prepareStatement("SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema = ?");
    		stmt.setString(1, database.getIdentifier());
    		
    		try {
    			ResultSet res = stmt.executeQuery();
    			try {
    				while (res.next()) {
    					String tableName = res.getString(2);
    					if (!isTableSourceToIgnore.execute(tableName))
    						result.add(new TableSourceInfo(getDatabaseServices(), database, tableName) );
    				}
    			} finally {
    				res.close();
    			}
    		} finally {
    			stmt.close();
    		}
    	} finally {
    		conn.close();
    	}
    	return result;
    }
    
    /**
	 *	Returns the list of foreign keys of the table source (e.g. table, view)
	 *	@param	tableSource	Table source from which we want to fetch the list of foreign keys
	 *	@return	The list of foreign keys of the table
	 *	@throws	SQLException	if an error occurs while accessing the database
	 */
    public Iterable<ITableSourceForeignKeyInfo> getTableSourceForeignKeys(ITableSourceInfo tableSource) throws SQLException {
        List<ITableSourceForeignKeyInfo> result = new LinkedList<ITableSourceForeignKeyInfo>();
        
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet res = null;
        
        try {
        	conn = getConnection();
        	
        	stmt = conn.prepareStatement("SELECT " +
                    " key_column_usage.constraint_name    AS constraint_name, " + 
                    " key_column_usage.column_name        AS source_column_name, " + 
                    " table_constraints.table_catalog     AS dest_database, " + 
                    " table_constraints.table_schema      AS dest_schema, " + 
                    " table_constraints.table_name        AS dest_table_name, " + 
                    " referential_constraints.delete_rule AS delete_rule, " + 
                    " dest_usage.column_name              AS dest_column_name " + 
                 " FROM information_schema.key_column_usage " + 
                 " INNER JOIN information_schema.referential_constraints ON (key_column_usage.constraint_name = referential_constraints.constraint_name) " + 
                 " INNER JOIN information_Schema.table_constraints ON (referential_constraints.unique_constraint_name = table_constraints.constraint_name) " + 
                 " INNER JOIN information_schema.key_column_usage AS dest_usage ON (table_constraints.constraint_name = dest_usage.constraint_name) " + 
                 " WHERE key_column_usage.table_name = ? AND key_column_usage.table_schema = ? " + 
                 " AND table_constraints.constraint_type = 'PRIMARY KEY'");
        	stmt.setString(1, tableSource.getName());
        	stmt.setString(2, tableSource.getDatabase().getIdentifier());
        	
        	res = stmt.executeQuery();
        	
        	while (res.next()) {
        		result.add(TableSourceForeignKeyInfo.create(getDatabaseServices(), tableSource, res));
        	}
        	
        } finally {
        	if (res  != null) try { res.close();  } catch (Exception e) {} 
        	if (stmt != null) try { stmt.close(); } catch (Exception e) {}
        	if (conn != null) try { conn.close(); } catch (Exception e) {}
        }
        
        return result;
    }
    
    /**
	 *	Returns the list of columns of the table source (e.g. table, view)
	 *	@param	tableSource	Table source from which we want to fetch the list of columns
	 *	@return	The columns of the table
	 *	@throws	SQLException	if an error occurs while accessing the database
	 */
    public Iterable<ITableSourceColumnInfo> getTableSourceColumns(ITableSourceInfo tableSource) throws SQLException {
        List<ITableSourceColumnInfo> result = new LinkedList<ITableSourceColumnInfo>();
        
        Connection conn = null;
        PreparedStatement stmt = null;
        ResultSet res = null;
        
        try {
        	conn = getConnection();
        	stmt = conn.prepareStatement("SELECT cols.column_name, " + 
                    " cols.data_type, " +  
                    " cols.is_nullable, " + 
                    " cols.column_default, " +  
                    " cols.character_maximum_length, " + 
                    " cols.numeric_precision, " +
                    " cols.numeric_precision_radix, " +  
                    " cols.numeric_scale, " + 
                    " cons.constraint_type " + 
            " FROM information_schema.columns cols " + 
            " LEFT JOIN " +  
            " ( " + 
            "  information_schema.key_column_usage usage " +
            "  INNER JOIN information_schema.table_constraints cons ON (cons.constraint_name = usage.constraint_name and cons.constraint_type = 'PRIMARY KEY') " +  
            " ) ON (cols.column_name = usage.column_name and cols.table_name = usage.table_name and cols.table_schema = usage.table_schema) " + 
            " WHERE cols.table_schema = ? " + 
            " AND cols.table_name = ? " + 
            " ORDER BY cols.ordinal_position");
        	
        	stmt.setString(1, tableSource.getDatabase().getIdentifier());
        	stmt.setString(2, tableSource.getName());
        	
        	res = stmt.executeQuery();
        	
        	while (res.next()) {
        		result.add(TableSourceColumnInfo.create(tableSource, res));
        	}
        	
        } finally {
        	if (res  != null) try { res.close();  } catch (Exception e) {} 
        	if (stmt != null) try { stmt.close(); } catch (Exception e) {}
        	if (conn != null) try { conn.close(); } catch (Exception e) {}
        }
        
        return result;
    }
    
    private Connection getConnection() throws SQLException {
    	return getDatabaseServices().getTransactionService().createConnection();
    }
    
}
